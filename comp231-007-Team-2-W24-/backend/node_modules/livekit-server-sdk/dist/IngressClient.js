import { CreateIngressRequest, DeleteIngressRequest, IngressInfo, ListIngressRequest, ListIngressResponse, UpdateIngressRequest, } from '@livekit/protocol';
import ServiceBase from './ServiceBase.js';
import { livekitPackage, TwirpRpc } from './TwirpRPC.js';
const svc = 'Ingress';
/**
 * Client to access Ingress APIs
 */
export class IngressClient extends ServiceBase {
    /**
     * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'
     * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY
     * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET
     */
    constructor(host, apiKey, secret) {
        super(apiKey, secret);
        this.rpc = new TwirpRpc(host, livekitPackage);
    }
    /**
     * @param inputType protocol for the ingress
     * @param opts CreateIngressOptions
     */
    async createIngress(inputType, opts) {
        let name = '';
        let roomName = '';
        let participantName = '';
        let participantIdentity = '';
        let bypassTranscoding = false;
        let url = '';
        let audio;
        let video;
        if (opts !== undefined) {
            name = opts.name || '';
            roomName = opts.roomName || '';
            participantName = opts.participantName || '';
            participantIdentity = opts.participantIdentity || '';
            bypassTranscoding = opts.bypassTranscoding || false;
            url = opts.url || '';
            audio = opts.audio;
            video = opts.video;
        }
        const req = new CreateIngressRequest({
            inputType,
            name,
            roomName,
            participantIdentity,
            participantName,
            bypassTranscoding,
            url,
            audio,
            video,
        }).toJson();
        const data = await this.rpc.request(svc, 'CreateIngress', req, await this.authHeader({ ingressAdmin: true }));
        return IngressInfo.fromJson(data, { ignoreUnknownFields: true });
    }
    /**
     * @param ingressId ID of the ingress to update
     * @param opts UpdateIngressOptions
     */
    async updateIngress(ingressId, opts) {
        const name = opts.name || '';
        const roomName = opts.roomName || '';
        const participantName = opts.participantName || '';
        const participantIdentity = opts.participantIdentity || '';
        const { audio, video, bypassTranscoding } = opts;
        const req = new UpdateIngressRequest({
            ingressId,
            name,
            roomName,
            participantIdentity,
            participantName,
            bypassTranscoding,
            audio,
            video,
        }).toJson();
        const data = await this.rpc.request(svc, 'UpdateIngress', req, await this.authHeader({ ingressAdmin: true }));
        return IngressInfo.fromJson(data, { ignoreUnknownFields: true });
    }
    async listIngress(arg) {
        var _a;
        let req = {};
        if (typeof arg === 'string') {
            req.roomName = arg;
        }
        else if (arg) {
            req = arg;
        }
        const data = await this.rpc.request(svc, 'ListIngress', new ListIngressRequest(req).toJson(), await this.authHeader({ ingressAdmin: true }));
        return (_a = ListIngressResponse.fromJson(data, { ignoreUnknownFields: true }).items) !== null && _a !== void 0 ? _a : [];
    }
    /**
     * @param ingressId ingress to delete
     */
    async deleteIngress(ingressId) {
        const data = await this.rpc.request(svc, 'DeleteIngress', new DeleteIngressRequest({ ingressId }).toJson(), await this.authHeader({ ingressAdmin: true }));
        return IngressInfo.fromJson(data, { ignoreUnknownFields: true });
    }
}
//# sourceMappingURL=IngressClient.js.map