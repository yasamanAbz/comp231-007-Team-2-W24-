{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/constants.ts\nvar cssPrefix = \"lk\";\n\n// src/utils.ts\nimport { LocalParticipant, RemoteParticipant } from \"livekit-client\";\n\n// src/track-reference/track-reference.types.ts\nfunction isTrackReference(trackReference) {\n  if (typeof trackReference === \"undefined\") {\n    return false;\n  }\n  return isTrackReferenceSubscribed(trackReference) || isTrackReferencePublished(trackReference);\n}\nfunction isTrackReferenceSubscribed(trackReference) {\n  var _a;\n  if (!trackReference) {\n    return false;\n  }\n  return trackReference.hasOwnProperty(\"participant\") && trackReference.hasOwnProperty(\"source\") && trackReference.hasOwnProperty(\"track\") && typeof ((_a = trackReference.publication) == null ? void 0 : _a.track) !== \"undefined\";\n}\nfunction isTrackReferencePublished(trackReference) {\n  if (!trackReference) {\n    return false;\n  }\n  return trackReference.hasOwnProperty(\"participant\") && trackReference.hasOwnProperty(\"source\") && trackReference.hasOwnProperty(\"publication\") && typeof trackReference.publication !== \"undefined\";\n}\nfunction isTrackReferencePlaceholder(trackReference) {\n  if (!trackReference) {\n    return false;\n  }\n  return trackReference.hasOwnProperty(\"participant\") && trackReference.hasOwnProperty(\"source\") && typeof trackReference.publication === \"undefined\";\n}\n\n// src/track-reference/track-reference.utils.ts\nfunction getTrackReferenceId(trackReference) {\n  if (typeof trackReference === \"string\" || typeof trackReference === \"number\") {\n    return `${trackReference}`;\n  } else if (isTrackReferencePlaceholder(trackReference)) {\n    return `${trackReference.participant.identity}_${trackReference.source}_placeholder`;\n  } else if (isTrackReference(trackReference)) {\n    return `${trackReference.participant.identity}_${trackReference.publication.source}_${trackReference.publication.trackSid}`;\n  } else {\n    throw new Error(`Can't generate a id for the given track reference: ${trackReference}`);\n  }\n}\nfunction getTrackReferenceSource(trackReference) {\n  if (isTrackReference(trackReference)) {\n    return trackReference.publication.source;\n  } else {\n    return trackReference.source;\n  }\n}\nfunction isEqualTrackRef(a, b) {\n  if (a === void 0 || b === void 0) {\n    return false;\n  }\n  if (isTrackReference(a) && isTrackReference(b)) {\n    return a.publication.trackSid === b.publication.trackSid;\n  } else {\n    return getTrackReferenceId(a) === getTrackReferenceId(b);\n  }\n}\nfunction isTrackReferencePinned(trackReference, pinState) {\n  if (typeof pinState === \"undefined\") {\n    return false;\n  }\n  if (isTrackReference(trackReference)) {\n    return pinState.some(pinnedTrackReference => pinnedTrackReference.participant.identity === trackReference.participant.identity && isTrackReference(pinnedTrackReference) && pinnedTrackReference.publication.trackSid === trackReference.publication.trackSid);\n  } else if (isTrackReferencePlaceholder(trackReference)) {\n    return pinState.some(pinnedTrackReference => pinnedTrackReference.participant.identity === trackReference.participant.identity && isTrackReferencePlaceholder(pinnedTrackReference) && pinnedTrackReference.source === trackReference.source);\n  } else {\n    return false;\n  }\n}\nfunction isPlaceholderReplacement(currentTrackRef, nextTrackRef) {\n  return isTrackReferencePlaceholder(currentTrackRef) && isTrackReference(nextTrackRef) && nextTrackRef.participant.identity === currentTrackRef.participant.identity && nextTrackRef.source === currentTrackRef.source;\n}\n\n// src/utils.ts\nfunction isLocal(p) {\n  return p instanceof LocalParticipant;\n}\nfunction isRemote(p) {\n  return p instanceof RemoteParticipant;\n}\nvar attachIfSubscribed = (publication, element) => {\n  if (!publication) return;\n  const {\n    isSubscribed,\n    track\n  } = publication;\n  if (element && track) {\n    if (isSubscribed) {\n      track.attach(element);\n    } else {\n      track.detach(element);\n    }\n  }\n};\nfunction isParticipantTrackReferencePinned(trackRef, pinState) {\n  if (pinState === void 0) {\n    return false;\n  }\n  return pinState.some(pinnedTrackRef => isEqualTrackRef(pinnedTrackRef, trackRef));\n}\nfunction getScrollBarWidth() {\n  const inner = document.createElement(\"p\");\n  inner.style.width = \"100%\";\n  inner.style.height = \"200px\";\n  const outer = document.createElement(\"div\");\n  outer.style.position = \"absolute\";\n  outer.style.top = \"0px\";\n  outer.style.left = \"0px\";\n  outer.style.visibility = \"hidden\";\n  outer.style.width = \"200px\";\n  outer.style.height = \"150px\";\n  outer.style.overflow = \"hidden\";\n  outer.appendChild(inner);\n  document.body.appendChild(outer);\n  const w1 = inner.offsetWidth;\n  outer.style.overflow = \"scroll\";\n  let w2 = inner.offsetWidth;\n  if (w1 === w2) {\n    w2 = outer.clientWidth;\n  }\n  document.body.removeChild(outer);\n  const scrollBarWidth = w1 - w2;\n  return scrollBarWidth;\n}\n\n// src/helper/detectMobileBrowser.ts\nfunction isWeb() {\n  return typeof document !== \"undefined\";\n}\nfunction isMobileBrowser() {\n  return isWeb() ? /Mobi/i.test(window.navigator.userAgent) : false;\n}\n\n// src/helper/url-regex.ts\nfunction createUrlRegExp(options) {\n  options = __spreadValues({}, options);\n  const protocol = `(?:(?:[a-z]+:)?//)?`;\n  const auth = \"(?:\\\\S+(?::\\\\S*)?@)?\";\n  const ip = new RegExp(\"(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}\", \"g\").source;\n  const host = \"(?:(?:[a-z\\\\u00a1-\\\\uffff0-9][-_]*)*[a-z\\\\u00a1-\\\\uffff0-9]+)\";\n  const domain = \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*\";\n  const tld = `(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\\\\.?`;\n  const port = \"(?::\\\\d{2,5})?\";\n  const path = '(?:[/?#][^\\\\s\"]*)?';\n  const regex = `(?:${protocol}|www\\\\.)${auth}(?:localhost|${ip}|${host}${domain}${tld})${port}${path}`;\n  return options.exact ? new RegExp(`(?:^${regex}$)`, \"i\") : new RegExp(regex, \"ig\");\n}\n\n// src/helper/emailRegex.ts\nimport createEmailRegExp from \"email-regex\";\n\n// src/helper/floating-menu.ts\nimport { computePosition, flip, offset, shift } from \"@floating-ui/dom\";\nfunction computeMenuPosition(button, menu) {\n  return __async(this, null, function* () {\n    const {\n      x,\n      y\n    } = yield computePosition(button, menu, {\n      placement: \"top\",\n      middleware: [offset(6), flip(), shift({\n        padding: 5\n      })]\n    });\n    return {\n      x,\n      y\n    };\n  });\n}\nfunction wasClickOutside(insideElement, event) {\n  const isOutside = !insideElement.contains(event.target);\n  return isOutside;\n}\n\n// src/helper/tokenizer.ts\nvar createDefaultGrammar = () => {\n  return {\n    email: createEmailRegExp(),\n    url: createUrlRegExp({})\n  };\n};\nfunction tokenize(input, grammar) {\n  const matches = Object.entries(grammar).map(([type, rx], weight) => Array.from(input.matchAll(rx)).map(({\n    index,\n    0: content\n  }) => ({\n    type,\n    weight,\n    content,\n    index: index != null ? index : 0\n  }))).flat().sort((a, b) => {\n    const d = a.index - b.index;\n    return d !== 0 ? d : a.weight - b.weight;\n  }).filter(({\n    index\n  }, i, arr) => {\n    if (i === 0) return true;\n    const prev = arr[i - 1];\n    return prev.index + prev.content.length <= index;\n  });\n  const tokens = [];\n  let pos = 0;\n  for (const {\n    type,\n    content,\n    index\n  } of matches) {\n    if (index > pos) tokens.push(input.substring(pos, index));\n    tokens.push({\n      type,\n      content\n    });\n    pos = index + content.length;\n  }\n  if (input.length > pos) tokens.push(input.substring(pos));\n  return tokens;\n}\n\n// src/helper/eventGroups.ts\nimport { ParticipantEvent, RoomEvent } from \"livekit-client\";\nvar allRemoteParticipantRoomEvents = [RoomEvent.ConnectionStateChanged, RoomEvent.RoomMetadataChanged, RoomEvent.ActiveSpeakersChanged, RoomEvent.ConnectionQualityChanged, RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ParticipantPermissionsChanged, RoomEvent.ParticipantMetadataChanged, RoomEvent.TrackMuted, RoomEvent.TrackUnmuted, RoomEvent.TrackPublished, RoomEvent.TrackUnpublished, RoomEvent.TrackStreamStateChanged, RoomEvent.TrackSubscriptionFailed, RoomEvent.TrackSubscriptionPermissionChanged, RoomEvent.TrackSubscriptionStatusChanged];\nvar allParticipantRoomEvents = [...allRemoteParticipantRoomEvents, RoomEvent.LocalTrackPublished, RoomEvent.LocalTrackUnpublished];\nvar participantTrackEvents = [ParticipantEvent.TrackPublished, ParticipantEvent.TrackUnpublished, ParticipantEvent.TrackMuted, ParticipantEvent.TrackUnmuted, ParticipantEvent.TrackStreamStateChanged, ParticipantEvent.TrackSubscribed, ParticipantEvent.TrackUnsubscribed, ParticipantEvent.TrackSubscriptionPermissionChanged, ParticipantEvent.TrackSubscriptionFailed, ParticipantEvent.LocalTrackPublished, ParticipantEvent.LocalTrackUnpublished];\nvar allRemoteParticipantEvents = [ParticipantEvent.ConnectionQualityChanged, ParticipantEvent.IsSpeakingChanged, ParticipantEvent.ParticipantMetadataChanged, ParticipantEvent.ParticipantPermissionsChanged, ParticipantEvent.TrackMuted, ParticipantEvent.TrackUnmuted, ParticipantEvent.TrackPublished, ParticipantEvent.TrackUnpublished, ParticipantEvent.TrackStreamStateChanged, ParticipantEvent.TrackSubscriptionFailed, ParticipantEvent.TrackSubscriptionPermissionChanged, ParticipantEvent.TrackSubscriptionStatusChanged];\nvar allParticipantEvents = [...allRemoteParticipantEvents, ParticipantEvent.LocalTrackPublished, ParticipantEvent.LocalTrackUnpublished];\n\n// src/logger.ts\nimport { setLogLevel as setClientSdkLogLevel, setLogExtension as setClientSdkLogExtension, LogLevel as LogLevelEnum } from \"livekit-client\";\nimport loglevel from \"loglevel\";\nvar log = loglevel.getLogger(\"lk-components-js\");\nlog.setDefaultLevel(\"WARN\");\nfunction setLogLevel(level, options = {}) {\n  var _a;\n  log.setLevel(level);\n  setClientSdkLogLevel((_a = options.liveKitClientLogLevel) != null ? _a : level);\n}\nfunction setLogExtension(extension, options = {}) {\n  var _a;\n  const originalFactory = log.methodFactory;\n  log.methodFactory = (methodName, configLevel, loggerName) => {\n    const rawMethod = originalFactory(methodName, configLevel, loggerName);\n    const logLevel = LogLevelEnum[methodName];\n    const needLog = logLevel >= configLevel && logLevel < LogLevelEnum.silent;\n    return (msg, context) => {\n      if (context) rawMethod(msg, context);else rawMethod(msg);\n      if (needLog) {\n        extension(logLevel, msg, context);\n      }\n    };\n  };\n  log.setLevel(log.getLevel());\n  setClientSdkLogExtension((_a = options.liveKitClientLogExtension) != null ? _a : extension);\n}\n\n// src/helper/grid-layouts.ts\nvar GRID_LAYOUTS = [{\n  columns: 1,\n  rows: 1,\n  name: \"1x1\",\n  minTiles: 1,\n  maxTiles: 1,\n  minWidth: 0,\n  minHeight: 0\n}, {\n  columns: 1,\n  rows: 2,\n  name: \"1x2\",\n  minTiles: 2,\n  maxTiles: 2,\n  minWidth: 0,\n  minHeight: 0\n}, {\n  columns: 2,\n  rows: 1,\n  name: \"2x1\",\n  minTiles: 2,\n  maxTiles: 2,\n  minWidth: 900,\n  minHeight: 0\n}, {\n  columns: 2,\n  rows: 2,\n  name: \"2x2\",\n  minTiles: 3,\n  maxTiles: 4,\n  minWidth: 560,\n  minHeight: 0\n}, {\n  columns: 3,\n  rows: 3,\n  name: \"3x3\",\n  minTiles: 5,\n  maxTiles: 9,\n  minWidth: 700,\n  minHeight: 0\n}, {\n  columns: 4,\n  rows: 4,\n  name: \"4x4\",\n  minTiles: 10,\n  maxTiles: 16,\n  minWidth: 960,\n  minHeight: 0\n}, {\n  columns: 5,\n  rows: 5,\n  name: \"5x5\",\n  minTiles: 17,\n  maxTiles: 25,\n  minWidth: 1100,\n  minHeight: 0\n}];\nfunction selectGridLayout(layouts, participantCount, width, height) {\n  let currentLayoutIndex = 0;\n  let layout = layouts.find((layout_, index, allLayouts) => {\n    currentLayoutIndex = index;\n    const isBiggerLayoutAvailable = allLayouts.findIndex((l, i) => {\n      const layoutIsBiggerThanCurrent = i > index;\n      const layoutFitsSameAmountOfParticipants = l.maxTiles === layout_.maxTiles;\n      return layoutIsBiggerThanCurrent && layoutFitsSameAmountOfParticipants;\n    }) !== -1;\n    return layout_.maxTiles >= participantCount && !isBiggerLayoutAvailable;\n  });\n  if (layout === void 0) {\n    layout = layouts[layouts.length - 1];\n    if (layout) {\n      log.warn(`No layout found for: participantCount: ${participantCount}, width/height: ${width}/${height} fallback to biggest available layout (${layout.name}).`);\n    } else {\n      throw new Error(`No layout or fallback layout found.`);\n    }\n  }\n  if (width < layout.minWidth || height < layout.minHeight) {\n    if (currentLayoutIndex > 0) {\n      const smallerLayout = layouts[currentLayoutIndex - 1];\n      layout = selectGridLayout(layouts.slice(0, currentLayoutIndex), smallerLayout.maxTiles, width, height);\n    }\n  }\n  return layout;\n}\n\n// src/helper/set-helper.ts\nfunction setDifference(setA, setB) {\n  const _difference = new Set(setA);\n  for (const elem of setB) {\n    _difference.delete(elem);\n  }\n  return _difference;\n}\n\n// src/helper/featureDetection.ts\nfunction supportsScreenSharing() {\n  return typeof navigator !== \"undefined\" && navigator.mediaDevices && !!navigator.mediaDevices.getDisplayMedia;\n}\n\n// src/types.ts\nvar PIN_DEFAULT_STATE = [];\nvar WIDGET_DEFAULT_STATE = {\n  showChat: false,\n  unreadMessages: 0,\n  showSettings: false\n};\nfunction isSourceWitOptions(source) {\n  return typeof source === \"object\";\n}\nfunction isSourcesWithOptions(sources) {\n  return Array.isArray(sources) && sources.filter(isSourceWitOptions).length > 0;\n}\n\n// src/sorting/sort-track-bundles.ts\nimport { Track as Track2 } from \"livekit-client\";\n\n// src/sorting/base-sort-functions.ts\nimport { Track } from \"livekit-client\";\nfunction sortParticipantsByAudioLevel(a, b) {\n  return b.audioLevel - a.audioLevel;\n}\nfunction sortParticipantsByIsSpeaking(a, b) {\n  if (a.isSpeaking === b.isSpeaking) {\n    return 0;\n  } else {\n    return a.isSpeaking ? -1 : 1;\n  }\n}\nfunction sortParticipantsByLastSpokenAT(a, b) {\n  var _a, _b, _c, _d;\n  if (a.lastSpokeAt !== void 0 || b.lastSpokeAt !== void 0) {\n    return ((_b = (_a = b.lastSpokeAt) == null ? void 0 : _a.getTime()) != null ? _b : 0) - ((_d = (_c = a.lastSpokeAt) == null ? void 0 : _c.getTime()) != null ? _d : 0);\n  } else {\n    return 0;\n  }\n}\nfunction sortParticipantsByJoinedAt(a, b) {\n  var _a, _b, _c, _d;\n  return ((_b = (_a = a.joinedAt) == null ? void 0 : _a.getTime()) != null ? _b : 0) - ((_d = (_c = b.joinedAt) == null ? void 0 : _c.getTime()) != null ? _d : 0);\n}\nfunction sortTrackReferencesByType(a, b) {\n  if (isTrackReference(a)) {\n    if (isTrackReference(b)) {\n      return 0;\n    } else {\n      return -1;\n    }\n  } else if (isTrackReference(b)) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\nfunction sortTrackRefsByIsCameraEnabled(a, b) {\n  const aVideo = a.participant.isCameraEnabled;\n  const bVideo = b.participant.isCameraEnabled;\n  if (aVideo !== bVideo) {\n    if (aVideo) {\n      return -1;\n    } else {\n      return 1;\n    }\n  } else {\n    return 0;\n  }\n}\n\n// src/sorting/sort-track-bundles.ts\nfunction sortTrackReferences(tracks) {\n  const localTracks = [];\n  const screenShareTracks = [];\n  const cameraTracks = [];\n  const undefinedTracks = [];\n  tracks.forEach(trackRef => {\n    if (trackRef.participant.isLocal && trackRef.source === Track2.Source.Camera) {\n      localTracks.push(trackRef);\n    } else if (trackRef.source === Track2.Source.ScreenShare) {\n      screenShareTracks.push(trackRef);\n    } else if (trackRef.source === Track2.Source.Camera) {\n      cameraTracks.push(trackRef);\n    } else {\n      undefinedTracks.push(trackRef);\n    }\n  });\n  const sortedScreenShareTracks = sortScreenShareTracks(screenShareTracks);\n  const sortedCameraTracks = sortCameraTracks(cameraTracks);\n  return [...localTracks, ...sortedScreenShareTracks, ...sortedCameraTracks, ...undefinedTracks];\n}\nfunction sortScreenShareTracks(screenShareTracks) {\n  const localScreenShares = [];\n  const remoteScreenShares = [];\n  screenShareTracks.forEach(trackRef => {\n    if (trackRef.participant.isLocal) {\n      localScreenShares.push(trackRef);\n    } else {\n      remoteScreenShares.push(trackRef);\n    }\n  });\n  localScreenShares.sort((a, b) => sortParticipantsByJoinedAt(a.participant, b.participant));\n  remoteScreenShares.sort((a, b) => sortParticipantsByJoinedAt(a.participant, b.participant));\n  const sortedScreenShareTrackRefs = [...remoteScreenShares, ...localScreenShares];\n  return sortedScreenShareTrackRefs;\n}\nfunction sortCameraTracks(cameraTrackReferences) {\n  const localCameraTracks = [];\n  const remoteCameraTracks = [];\n  cameraTrackReferences.forEach(trackRef => {\n    if (trackRef.participant.isLocal) {\n      localCameraTracks.push(trackRef);\n    } else {\n      remoteCameraTracks.push(trackRef);\n    }\n  });\n  remoteCameraTracks.sort((a, b) => {\n    if (a.participant.isSpeaking && b.participant.isSpeaking) {\n      return sortParticipantsByAudioLevel(a.participant, b.participant);\n    }\n    if (a.participant.isSpeaking !== b.participant.isSpeaking) {\n      return sortParticipantsByIsSpeaking(a.participant, b.participant);\n    }\n    if (a.participant.lastSpokeAt !== b.participant.lastSpokeAt) {\n      return sortParticipantsByLastSpokenAT(a.participant, b.participant);\n    }\n    if (isTrackReference(a) !== isTrackReference(b)) {\n      return sortTrackReferencesByType(a, b);\n    }\n    if (a.participant.isCameraEnabled !== b.participant.isCameraEnabled) {\n      return sortTrackRefsByIsCameraEnabled(a, b);\n    }\n    return sortParticipantsByJoinedAt(a.participant, b.participant);\n  });\n  return [...localCameraTracks, ...remoteCameraTracks];\n}\n\n// src/sorting/sort-participants.ts\nimport { LocalParticipant as LocalParticipant2 } from \"livekit-client\";\nfunction sortParticipants(participants) {\n  const sortedParticipants = [...participants];\n  sortedParticipants.sort((a, b) => {\n    if (a.isSpeaking && b.isSpeaking) {\n      return sortParticipantsByAudioLevel(a, b);\n    }\n    if (a.isSpeaking !== b.isSpeaking) {\n      return sortParticipantsByIsSpeaking(a, b);\n    }\n    if (a.lastSpokeAt !== b.lastSpokeAt) {\n      return sortParticipantsByLastSpokenAT(a, b);\n    }\n    const aVideo = a.videoTrackPublications.size > 0;\n    const bVideo = b.videoTrackPublications.size > 0;\n    if (aVideo !== bVideo) {\n      if (aVideo) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n    return sortParticipantsByJoinedAt(a, b);\n  });\n  const localParticipant = sortedParticipants.find(p => p instanceof LocalParticipant2);\n  if (localParticipant) {\n    const localIdx = sortedParticipants.indexOf(localParticipant);\n    if (localIdx >= 0) {\n      sortedParticipants.splice(localIdx, 1);\n      if (sortedParticipants.length > 0) {\n        sortedParticipants.splice(0, 0, localParticipant);\n      } else {\n        sortedParticipants.push(localParticipant);\n      }\n    }\n  }\n  return sortedParticipants;\n}\n\n// src/helper/array-helper.ts\nfunction chunk(input, size) {\n  return input.reduce((arr, item, idx) => {\n    return idx % size === 0 ? [...arr, [item]] : [...arr.slice(0, -1), [...arr.slice(-1)[0], item]];\n  }, []);\n}\nfunction zip(a1, a2) {\n  const resultLength = Math.max(a1.length, a2.length);\n  return new Array(resultLength).fill([]).map((_val, idx) => [a1[idx], a2[idx]]);\n}\nfunction differenceBy(a1, a2, by) {\n  return a1.filter(c => !a2.map(v => by(v)).includes(by(c)));\n}\n\n// src/track-reference/test-utils.ts\nimport { Participant, Track as Track3, TrackPublication } from \"livekit-client\";\nfunction flatTrackReferenceArray(list) {\n  return list.map(item => {\n    if (typeof item === \"string\" || typeof item === \"number\") {\n      return `${item}`;\n    } else {\n      return getTrackReferenceId(item);\n    }\n  });\n}\n\n// src/sorting/tile-array-update.ts\nfunction visualPageChange(state, next) {\n  return {\n    dropped: differenceBy(state, next, getTrackReferenceId),\n    added: differenceBy(next, state, getTrackReferenceId)\n  };\n}\nfunction listNeedsUpdating(changes) {\n  return changes.added.length !== 0 || changes.dropped.length !== 0;\n}\nfunction findIndex(trackReference, trackReferences) {\n  const indexToReplace = trackReferences.findIndex(trackReference_ => getTrackReferenceId(trackReference_) === getTrackReferenceId(trackReference));\n  if (indexToReplace === -1) {\n    throw new Error(`Element not part of the array: ${getTrackReferenceId(trackReference)} not in ${flatTrackReferenceArray(trackReferences)}`);\n  }\n  return indexToReplace;\n}\nfunction swapItems(moveForward, moveBack, trackReferences) {\n  const indexToReplace = findIndex(moveForward, trackReferences);\n  const indexReplaceWith = findIndex(moveBack, trackReferences);\n  trackReferences.splice(indexToReplace, 1, moveBack);\n  trackReferences.splice(indexReplaceWith, 1, moveForward);\n  return trackReferences;\n}\nfunction dropItem(itemToDrop, list) {\n  const indexOfElementToDrop = findIndex(itemToDrop, list);\n  list.splice(indexOfElementToDrop, 1);\n  return list;\n}\nfunction addItem(itemToAdd, list) {\n  return [...list, itemToAdd];\n}\nfunction divideIntoPages(list, maxElementsOnPage) {\n  const pages = chunk(list, maxElementsOnPage);\n  return pages;\n}\nfunction updatePages(currentList, nextList, maxItemsOnPage) {\n  let updatedList = refreshList(currentList, nextList);\n  if (updatedList.length < nextList.length) {\n    const addedItems = differenceBy(nextList, updatedList, getTrackReferenceId);\n    updatedList = [...updatedList, ...addedItems];\n  }\n  const currentPages = divideIntoPages(updatedList, maxItemsOnPage);\n  const nextPages = divideIntoPages(nextList, maxItemsOnPage);\n  zip(currentPages, nextPages).forEach(([currentPage, nextPage], pageIndex) => {\n    if (currentPage && nextPage) {\n      const updatedPage = divideIntoPages(updatedList, maxItemsOnPage)[pageIndex];\n      const changes = visualPageChange(updatedPage, nextPage);\n      if (listNeedsUpdating(changes)) {\n        log.debug(`Detected visual changes on page: ${pageIndex}, current: ${flatTrackReferenceArray(currentPage)}, next: ${flatTrackReferenceArray(nextPage)}`, {\n          changes\n        });\n        if (changes.added.length === changes.dropped.length) {\n          zip(changes.added, changes.dropped).forEach(([added, dropped]) => {\n            if (added && dropped) {\n              updatedList = swapItems(added, dropped, updatedList);\n            } else {\n              throw new Error(`For a swap action we need a addition and a removal one is missing: ${added}, ${dropped}`);\n            }\n          });\n        }\n        if (changes.added.length === 0 && changes.dropped.length > 0) {\n          changes.dropped.forEach(item => {\n            updatedList = dropItem(item, updatedList);\n          });\n        }\n        if (changes.added.length > 0 && changes.dropped.length === 0) {\n          changes.added.forEach(item => {\n            updatedList = addItem(item, updatedList);\n          });\n        }\n      }\n    }\n  });\n  if (updatedList.length > nextList.length) {\n    const missingItems = differenceBy(updatedList, nextList, getTrackReferenceId);\n    updatedList = updatedList.filter(item => !missingItems.map(getTrackReferenceId).includes(getTrackReferenceId(item)));\n  }\n  return updatedList;\n}\nfunction refreshList(currentList, nextList) {\n  return currentList.map(currentItem => {\n    const updateForCurrentItem = nextList.find(newItem_ =>\n    // If the IDs match or ..\n    getTrackReferenceId(currentItem) === getTrackReferenceId(newItem_) ||\n    // ... if the current item is a placeholder and the new item is the track reference can replace it.\n    typeof currentItem !== \"number\" && isTrackReferencePlaceholder(currentItem) && isTrackReference(newItem_) && isPlaceholderReplacement(currentItem, newItem_));\n    return updateForCurrentItem != null ? updateForCurrentItem : currentItem;\n  });\n}\n\n// src/components/mediaToggle.ts\nimport { Track as Track7 } from \"livekit-client\";\nimport { Subject as Subject2, map as map4, startWith as startWith4 } from \"rxjs\";\n\n// src/observables/participant.ts\nimport { ParticipantEvent as ParticipantEvent2, RoomEvent as RoomEvent3, Track as Track6 } from \"livekit-client\";\nimport { Observable as Observable2, map as map3, startWith as startWith3, switchMap } from \"rxjs\";\n\n// src/components/mediaTrack.ts\nimport { Track as Track4 } from \"livekit-client\";\nimport { map, startWith } from \"rxjs\";\n\n// src/styles-interface/class-prefixer.ts\nfunction prefixClass(unprefixedClassName) {\n  return `${cssPrefix}-${unprefixedClassName}`;\n}\n\n// src/components/mediaTrack.ts\nfunction setupMediaTrack(trackIdentifier) {\n  const initialPub = getTrackByIdentifier(trackIdentifier);\n  const trackObserver = observeParticipantMedia(trackIdentifier.participant).pipe(map(() => {\n    return getTrackByIdentifier(trackIdentifier);\n  }), startWith(initialPub));\n  const className = prefixClass(trackIdentifier.source === Track4.Source.Camera || trackIdentifier.source === Track4.Source.ScreenShare ? \"participant-media-video\" : \"participant-media-audio\");\n  return {\n    className,\n    trackObserver\n  };\n}\nfunction getTrackByIdentifier(options) {\n  if (isTrackReference(options)) {\n    return options.publication;\n  } else {\n    const {\n      source,\n      name,\n      participant\n    } = options;\n    if (source && name) {\n      return participant.getTrackPublications().find(pub => pub.source === source && pub.trackName === name);\n    } else if (name) {\n      return participant.getTrackPublicationByName(name);\n    } else if (source) {\n      return participant.getTrackPublication(source);\n    } else {\n      throw new Error(\"At least one of source and name needs to be defined\");\n    }\n  }\n}\n\n// src/observables/room.ts\nimport { Subject, map as map2, Observable, startWith as startWith2, finalize, filter, concat } from \"rxjs\";\nimport { LocalParticipant as LocalParticipant3, Room, RoomEvent as RoomEvent2, Track as Track5 } from \"livekit-client\";\nfunction observeRoomEvents(room, ...events) {\n  const observable = new Observable(subscribe => {\n    const onRoomUpdate = () => {\n      subscribe.next(room);\n    };\n    events.forEach(evt => {\n      room.on(evt, onRoomUpdate);\n    });\n    const unsubscribe = () => {\n      events.forEach(evt => {\n        room.off(evt, onRoomUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith2(room));\n  return observable;\n}\nfunction roomEventSelector(room, event) {\n  const observable = new Observable(subscribe => {\n    const update = (...params) => {\n      subscribe.next(params);\n    };\n    room.on(event, update);\n    const unsubscribe = () => {\n      room.off(event, update);\n    };\n    return unsubscribe;\n  });\n  return observable;\n}\nfunction roomObserver(room) {\n  const observable = observeRoomEvents(room, RoomEvent2.ParticipantConnected, RoomEvent2.ParticipantDisconnected, RoomEvent2.ActiveSpeakersChanged, RoomEvent2.TrackSubscribed, RoomEvent2.TrackUnsubscribed, RoomEvent2.LocalTrackPublished, RoomEvent2.LocalTrackUnpublished, RoomEvent2.AudioPlaybackStatusChanged, RoomEvent2.ConnectionStateChanged).pipe(startWith2(room));\n  return observable;\n}\nfunction connectionStateObserver(room) {\n  return roomEventSelector(room, RoomEvent2.ConnectionStateChanged).pipe(map2(([connectionState]) => connectionState), startWith2(room.state));\n}\nfunction screenShareObserver(room) {\n  let screenShareSubscriber;\n  const observers = [];\n  const observable = new Observable(subscriber => {\n    screenShareSubscriber = subscriber;\n    return () => {\n      observers.forEach(observer => {\n        observer.unsubscribe();\n      });\n    };\n  });\n  const screenShareTracks = [];\n  const handleSub = (publication, participant) => {\n    if (publication.source !== Track5.Source.ScreenShare && publication.source !== Track5.Source.ScreenShareAudio) {\n      return;\n    }\n    let trackMap = screenShareTracks.find(tr => tr.participant.identity === participant.identity);\n    const getScreenShareTracks = participant2 => {\n      return participant2.getTrackPublications().filter(track => (track.source === Track5.Source.ScreenShare || track.source === Track5.Source.ScreenShareAudio) && track.track);\n    };\n    if (!trackMap) {\n      trackMap = {\n        participant,\n        tracks: getScreenShareTracks(participant)\n      };\n    } else {\n      const index = screenShareTracks.indexOf(trackMap);\n      screenShareTracks.splice(index, 1);\n      trackMap.tracks = getScreenShareTracks(participant);\n    }\n    if (trackMap.tracks.length > 0) {\n      screenShareTracks.push(trackMap);\n    }\n    screenShareSubscriber.next(screenShareTracks);\n  };\n  observers.push(roomEventSelector(room, RoomEvent2.TrackSubscribed).subscribe(([, ...args]) => handleSub(...args)));\n  observers.push(roomEventSelector(room, RoomEvent2.TrackUnsubscribed).subscribe(([, ...args]) => handleSub(...args)));\n  observers.push(roomEventSelector(room, RoomEvent2.LocalTrackPublished).subscribe(args => handleSub(...args)));\n  observers.push(roomEventSelector(room, RoomEvent2.LocalTrackUnpublished).subscribe(args => {\n    handleSub(...args);\n  }));\n  observers.push(roomEventSelector(room, RoomEvent2.TrackMuted).subscribe(args => {\n    handleSub(...args);\n  }));\n  observers.push(roomEventSelector(room, RoomEvent2.TrackUnmuted).subscribe(args => {\n    handleSub(...args);\n  }));\n  setTimeout(() => {\n    for (const p of room.remoteParticipants.values()) {\n      p.getTrackPublications().forEach(track => {\n        handleSub(track, p);\n      });\n    }\n  }, 1);\n  return observable;\n}\nfunction roomInfoObserver(room) {\n  const observer = observeRoomEvents(room, RoomEvent2.RoomMetadataChanged, RoomEvent2.ConnectionStateChanged).pipe(map2(r => {\n    return {\n      name: r.name,\n      metadata: r.metadata\n    };\n  }));\n  return observer;\n}\nfunction activeSpeakerObserver(room) {\n  return roomEventSelector(room, RoomEvent2.ActiveSpeakersChanged).pipe(map2(([speakers]) => speakers));\n}\nfunction createMediaDeviceObserver(kind, onError, requestPermissions = true) {\n  var _a;\n  const onDeviceChange = () => __async(this, null, function* () {\n    try {\n      const newDevices = yield Room.getLocalDevices(kind, requestPermissions);\n      deviceSubject.next(newDevices);\n    } catch (e) {\n      onError == null ? void 0 : onError(e);\n    }\n  });\n  const deviceSubject = new Subject();\n  const observable = deviceSubject.pipe(finalize(() => {\n    var _a2;\n    (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.removeEventListener(\"devicechange\", onDeviceChange);\n  }));\n  if (typeof window !== \"undefined\") {\n    if (!window.isSecureContext) {\n      throw new Error(`Accessing media devices is available only in secure contexts (HTTPS and localhost), in some or all supporting browsers. See: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/mediaDevices`);\n    }\n    (_a = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a.addEventListener(\"devicechange\", onDeviceChange);\n  }\n  return concat(Room.getLocalDevices(kind, requestPermissions).catch(e => {\n    onError == null ? void 0 : onError(e);\n    return [];\n  }), observable);\n}\nfunction createDataObserver(room) {\n  return roomEventSelector(room, RoomEvent2.DataReceived);\n}\nfunction roomAudioPlaybackAllowedObservable(room) {\n  const observable = observeRoomEvents(room, RoomEvent2.AudioPlaybackStatusChanged).pipe(map2(room2 => {\n    return {\n      canPlayAudio: room2.canPlaybackAudio\n    };\n  }));\n  return observable;\n}\nfunction roomVideoPlaybackAllowedObservable(room) {\n  const observable = observeRoomEvents(room, RoomEvent2.VideoPlaybackStatusChanged).pipe(map2(room2 => {\n    return {\n      canPlayVideo: room2.canPlaybackVideo\n    };\n  }));\n  return observable;\n}\nfunction createActiveDeviceObservable(room, kind) {\n  return roomEventSelector(room, RoomEvent2.ActiveDeviceChanged).pipe(filter(([kindOfDevice]) => kindOfDevice === kind), map2(([kind2, deviceId]) => {\n    log.debug(\"activeDeviceObservable | RoomEvent.ActiveDeviceChanged\", {\n      kind: kind2,\n      deviceId\n    });\n    return deviceId;\n  }), startWith2(room.getActiveDevice(kind)));\n}\nfunction encryptionStatusObservable(room, participant) {\n  return roomEventSelector(room, RoomEvent2.ParticipantEncryptionStatusChanged).pipe(filter(([, p]) => participant.identity === (p == null ? void 0 : p.identity) || !p && participant.identity === room.localParticipant.identity), map2(([encrypted]) => encrypted), startWith2(participant instanceof LocalParticipant3 ? participant.isE2EEEnabled : participant.isEncrypted));\n}\n\n// src/observables/participant.ts\nfunction observeParticipantEvents(participant, ...events) {\n  const observable = new Observable2(subscribe => {\n    const onParticipantUpdate = () => {\n      subscribe.next(participant);\n    };\n    events.forEach(evt => {\n      participant.on(evt, onParticipantUpdate);\n    });\n    const unsubscribe = () => {\n      events.forEach(evt => {\n        participant.off(evt, onParticipantUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith3(participant));\n  return observable;\n}\nfunction observeParticipantMedia(participant) {\n  const participantObserver = observeParticipantEvents(participant, ParticipantEvent2.TrackMuted, ParticipantEvent2.TrackUnmuted, ParticipantEvent2.ParticipantPermissionsChanged,\n  // ParticipantEvent.IsSpeakingChanged,\n  ParticipantEvent2.TrackPublished, ParticipantEvent2.TrackUnpublished, ParticipantEvent2.LocalTrackPublished, ParticipantEvent2.LocalTrackUnpublished, ParticipantEvent2.MediaDevicesError, ParticipantEvent2.TrackSubscriptionStatusChanged\n  // ParticipantEvent.ConnectionQualityChanged,\n  ).pipe(map3(p => {\n    const {\n      isMicrophoneEnabled,\n      isCameraEnabled,\n      isScreenShareEnabled\n    } = p;\n    const microphoneTrack = p.getTrackPublication(Track6.Source.Microphone);\n    const cameraTrack = p.getTrackPublication(Track6.Source.Camera);\n    const participantMedia = {\n      isCameraEnabled,\n      isMicrophoneEnabled,\n      isScreenShareEnabled,\n      cameraTrack,\n      microphoneTrack,\n      participant: p\n    };\n    return participantMedia;\n  }));\n  return participantObserver;\n}\nfunction createTrackObserver(participant, options) {\n  return observeParticipantMedia(participant).pipe(map3(() => {\n    return {\n      publication: getTrackByIdentifier(options)\n    };\n  }));\n}\nfunction participantInfoObserver(participant) {\n  const observer = observeParticipantEvents(participant, ParticipantEvent2.ParticipantMetadataChanged\n  // ParticipantEvent.LocalTrackPublished,\n  ).pipe(map3(({\n    name,\n    identity,\n    metadata\n  }) => {\n    return {\n      name,\n      identity,\n      metadata\n    };\n  }), startWith3({\n    name: participant.name,\n    identity: participant.identity,\n    metadata: participant.metadata\n  }));\n  return observer;\n}\nfunction createConnectionQualityObserver(participant) {\n  const observer = participantEventSelector(participant, ParticipantEvent2.ConnectionQualityChanged).pipe(map3(([quality]) => quality), startWith3(participant.connectionQuality));\n  return observer;\n}\nfunction participantEventSelector(participant, event) {\n  const observable = new Observable2(subscribe => {\n    const update = (...params) => {\n      subscribe.next(params);\n    };\n    participant.on(event, update);\n    const unsubscribe = () => {\n      participant.off(event, update);\n    };\n    return unsubscribe;\n  });\n  return observable;\n}\nfunction mutedObserver(trackRef) {\n  var _a, _b, _c, _d;\n  return observeParticipantEvents(trackRef.participant, ParticipantEvent2.TrackMuted, ParticipantEvent2.TrackUnmuted, ParticipantEvent2.TrackSubscribed, ParticipantEvent2.TrackUnsubscribed, ParticipantEvent2.LocalTrackPublished, ParticipantEvent2.LocalTrackUnpublished).pipe(map3(participant => {\n    var _a2, _b2;\n    const pub = (_a2 = trackRef.publication) != null ? _a2 : participant.getTrackPublication(trackRef.source);\n    return (_b2 = pub == null ? void 0 : pub.isMuted) != null ? _b2 : true;\n  }), startWith3((_d = (_c = (_a = trackRef.publication) == null ? void 0 : _a.isMuted) != null ? _c : (_b = trackRef.participant.getTrackPublication(trackRef.source)) == null ? void 0 : _b.isMuted) != null ? _d : true));\n}\nfunction createIsSpeakingObserver(participant) {\n  return participantEventSelector(participant, ParticipantEvent2.IsSpeakingChanged).pipe(map3(([isSpeaking]) => isSpeaking));\n}\nfunction connectedParticipantsObserver(room, options = {}) {\n  var _a;\n  let subscriber;\n  const observable = new Observable2(sub => {\n    subscriber = sub;\n    return () => listener.unsubscribe();\n  }).pipe(startWith3(Array.from(room.remoteParticipants.values())));\n  const additionalRoomEvents = (_a = options.additionalRoomEvents) != null ? _a : allParticipantRoomEvents;\n  const roomEvents = Array.from( /* @__PURE__ */new Set([RoomEvent3.ParticipantConnected, RoomEvent3.ParticipantDisconnected, RoomEvent3.ConnectionStateChanged, ...additionalRoomEvents]));\n  const listener = observeRoomEvents(room, ...roomEvents).subscribe(r => subscriber == null ? void 0 : subscriber.next(Array.from(r.remoteParticipants.values())));\n  if (room.remoteParticipants.size > 0) {\n    subscriber == null ? void 0 : subscriber.next(Array.from(room.remoteParticipants.values()));\n  }\n  return observable;\n}\nfunction connectedParticipantObserver(room, identity, options = {}) {\n  var _a;\n  const additionalEvents = (_a = options.additionalEvents) != null ? _a : allParticipantEvents;\n  const observable = observeRoomEvents(room, RoomEvent3.ParticipantConnected, RoomEvent3.ParticipantDisconnected, RoomEvent3.ConnectionStateChanged).pipe(switchMap(r => {\n    const participant = r.getParticipantByIdentity(identity);\n    if (participant) {\n      return observeParticipantEvents(participant, ...additionalEvents);\n    } else {\n      return new Observable2(subscribe => subscribe.next(void 0));\n    }\n  }), startWith3(room.getParticipantByIdentity(identity)));\n  return observable;\n}\nfunction participantPermissionObserver(participant) {\n  const observer = participantEventSelector(participant, ParticipantEvent2.ParticipantPermissionsChanged).pipe(map3(() => participant.permissions), startWith3(participant.permissions));\n  return observer;\n}\n\n// src/components/mediaToggle.ts\nfunction setupMediaToggle(source, room, options) {\n  const {\n    localParticipant\n  } = room;\n  const getSourceEnabled = (source2, localParticipant2) => {\n    let isEnabled = false;\n    switch (source2) {\n      case Track7.Source.Camera:\n        isEnabled = localParticipant2.isCameraEnabled;\n        break;\n      case Track7.Source.Microphone:\n        isEnabled = localParticipant2.isMicrophoneEnabled;\n        break;\n      case Track7.Source.ScreenShare:\n        isEnabled = localParticipant2.isScreenShareEnabled;\n        break;\n      default:\n        break;\n    }\n    return isEnabled;\n  };\n  const enabledObserver = observeParticipantMedia(localParticipant).pipe(map4(media => {\n    return getSourceEnabled(source, media.participant);\n  }), startWith4(getSourceEnabled(source, localParticipant)));\n  const pendingSubject = new Subject2();\n  const toggle = (forceState, captureOptions) => __async(this, null, function* () {\n    try {\n      captureOptions != null ? captureOptions : captureOptions = options;\n      pendingSubject.next(true);\n      switch (source) {\n        case Track7.Source.Camera:\n          yield localParticipant.setCameraEnabled(forceState != null ? forceState : !localParticipant.isCameraEnabled, captureOptions);\n          break;\n        case Track7.Source.Microphone:\n          yield localParticipant.setMicrophoneEnabled(forceState != null ? forceState : !localParticipant.isMicrophoneEnabled, captureOptions);\n          break;\n        case Track7.Source.ScreenShare:\n          yield localParticipant.setScreenShareEnabled(forceState != null ? forceState : !localParticipant.isScreenShareEnabled, captureOptions);\n          break;\n        default:\n          break;\n      }\n    } finally {\n      pendingSubject.next(false);\n    }\n  });\n  const className = prefixClass(\"button\");\n  return {\n    className,\n    toggle,\n    enabledObserver,\n    pendingObserver: pendingSubject.asObservable()\n  };\n}\nfunction setupManualToggle() {\n  let state = false;\n  const enabledSubject = new Subject2();\n  const pendingSubject = new Subject2();\n  const toggle = forceState => __async(this, null, function* () {\n    pendingSubject.next(true);\n    state = forceState != null ? forceState : !state;\n    enabledSubject.next(state);\n    pendingSubject.next(false);\n  });\n  const className = prefixClass(\"button\");\n  return {\n    className,\n    toggle,\n    enabledObserver: enabledSubject.asObservable(),\n    pendingObserver: pendingSubject.asObservable()\n  };\n}\n\n// src/components/mediaDeviceSelect.ts\nimport { Track as Track8 } from \"livekit-client\";\nimport { BehaviorSubject } from \"rxjs\";\nfunction setupDeviceSelector(kind, room, localTrack) {\n  const activeDeviceSubject = new BehaviorSubject(void 0);\n  const activeDeviceObservable = room ? createActiveDeviceObservable(room, kind) : activeDeviceSubject.asObservable();\n  const setActiveMediaDevice = (_0, ..._1) => __async(this, [_0, ..._1], function* (id, options = {}) {\n    var _a, _b, _c;\n    if (room) {\n      log.debug(`Switching active device of kind \"${kind}\" with id ${id}.`);\n      yield room.switchActiveDevice(kind, id, options.exact);\n      const actualDeviceId = (_a = room.getActiveDevice(kind)) != null ? _a : id;\n      if (actualDeviceId !== id && id !== \"default\") {\n        log.info(`We tried to select the device with id (${id}), but the browser decided to select the device with id (${actualDeviceId}) instead.`);\n      }\n      let targetTrack = void 0;\n      if (kind === \"audioinput\") targetTrack = (_b = room.localParticipant.getTrackPublication(Track8.Source.Microphone)) == null ? void 0 : _b.track;else if (kind === \"videoinput\") {\n        targetTrack = (_c = room.localParticipant.getTrackPublication(Track8.Source.Camera)) == null ? void 0 : _c.track;\n      }\n      const useDefault = id === \"default\" && !targetTrack || id === \"default\" && (targetTrack == null ? void 0 : targetTrack.mediaStreamTrack.label.startsWith(\"Default\"));\n      activeDeviceSubject.next(useDefault ? id : actualDeviceId);\n    } else if (localTrack) {\n      yield localTrack.setDeviceId(options.exact ? {\n        exact: id\n      } : id);\n      const actualId = yield localTrack.getDeviceId();\n      activeDeviceSubject.next(id === \"default\" && localTrack.mediaStreamTrack.label.startsWith(\"Default\") ? id : actualId);\n    } else if (activeDeviceSubject.value !== id) {\n      log.warn(\"device switch skipped, please provide either a room or a local track to switch on. \");\n      activeDeviceSubject.next(id);\n    }\n  });\n  const className = prefixClass(\"media-device-select\");\n  return {\n    className,\n    activeDeviceObservable,\n    setActiveMediaDevice\n  };\n}\n\n// src/components/disconnectButton.ts\nfunction setupDisconnectButton(room) {\n  const disconnect = stopTracks => {\n    room.disconnect(stopTracks);\n  };\n  const className = prefixClass(\"disconnect-button\");\n  return {\n    className,\n    disconnect\n  };\n}\n\n// src/components/connectionQualityIndicator.ts\nfunction setupConnectionQualityIndicator(participant) {\n  const className = prefixClass(\"connection-quality\");\n  const connectionQualityObserver = createConnectionQualityObserver(participant);\n  return {\n    className,\n    connectionQualityObserver\n  };\n}\n\n// src/components/trackMutedIndicator.ts\nimport { Track as Track9 } from \"livekit-client\";\nfunction setupTrackMutedIndicator(trackRef) {\n  let classForSource = \"track-muted-indicator-camera\";\n  switch (trackRef.source) {\n    case Track9.Source.Camera:\n      classForSource = \"track-muted-indicator-camera\";\n      break;\n    case Track9.Source.Microphone:\n      classForSource = \"track-muted-indicator-microphone\";\n      break;\n    default:\n      break;\n  }\n  const className = prefixClass(classForSource);\n  const mediaMutedObserver = mutedObserver(trackRef);\n  return {\n    className,\n    mediaMutedObserver\n  };\n}\n\n// src/components/participantName.ts\nfunction setupParticipantName(participant) {\n  const infoObserver = participantInfoObserver(participant);\n  return {\n    className: \"lk-participant-name\",\n    infoObserver\n  };\n}\n\n// src/components/participantTile.ts\nfunction setupParticipantTile() {\n  const className = prefixClass(\"participant-tile\");\n  return {\n    className\n  };\n}\n\n// src/components/chat.ts\nimport { RoomEvent as RoomEvent4 } from \"livekit-client\";\nimport { BehaviorSubject as BehaviorSubject2, Subject as Subject3, scan, map as map6, takeUntil } from \"rxjs\";\n\n// src/observables/dataChannel.ts\nimport { Observable as Observable3, filter as filter2, map as map5 } from \"rxjs\";\nvar DataTopic = {\n  CHAT: \"lk-chat-topic\",\n  CHAT_UPDATE: \"lk-chat-update-topic\"\n};\nfunction sendMessage(_0, _1) {\n  return __async(this, arguments, function* (localParticipant, payload, options = {}) {\n    const {\n      reliable,\n      destinationIdentities,\n      topic\n    } = options;\n    yield localParticipant.publishData(payload, {\n      destinationIdentities,\n      topic,\n      reliable\n    });\n  });\n}\nfunction setupDataMessageHandler(room, topic, onMessage) {\n  const topics = Array.isArray(topic) ? topic : [topic];\n  const messageObservable = createDataObserver(room).pipe(filter2(([,,, messageTopic]) => topic === void 0 || messageTopic !== void 0 && topics.includes(messageTopic)), map5(([payload, participant,, messageTopic]) => {\n    const msg = {\n      payload,\n      topic: messageTopic,\n      from: participant\n    };\n    onMessage == null ? void 0 : onMessage(msg);\n    return msg;\n  }));\n  let isSendingSubscriber;\n  const isSendingObservable = new Observable3(subscriber => {\n    isSendingSubscriber = subscriber;\n  });\n  const send = (_0, ..._1) => __async(this, [_0, ..._1], function* (payload, options = {}) {\n    isSendingSubscriber.next(true);\n    try {\n      yield sendMessage(room.localParticipant, payload, __spreadValues({\n        topic: topics[0]\n      }, options));\n    } finally {\n      isSendingSubscriber.next(false);\n    }\n  });\n  return {\n    messageObservable,\n    isSendingObservable,\n    send\n  };\n}\n\n// src/components/chat.ts\nvar encoder = new TextEncoder();\nvar decoder = new TextDecoder();\nvar topicSubjectMap = /* @__PURE__ */new Map();\nvar encode = message => encoder.encode(JSON.stringify(message));\nvar decode = message => JSON.parse(decoder.decode(message));\nfunction setupChat(room, options) {\n  var _a, _b;\n  const onDestroyObservable = new Subject3();\n  const {\n    messageDecoder,\n    messageEncoder,\n    channelTopic,\n    updateChannelTopic\n  } = options != null ? options : {};\n  const topic = channelTopic != null ? channelTopic : DataTopic.CHAT;\n  const updateTopic = updateChannelTopic != null ? updateChannelTopic : DataTopic.CHAT_UPDATE;\n  let needsSetup = false;\n  if (!topicSubjectMap.has(room)) {\n    needsSetup = true;\n  }\n  const topicMap = (_a = topicSubjectMap.get(room)) != null ? _a : /* @__PURE__ */new Map();\n  const messageSubject = (_b = topicMap.get(topic)) != null ? _b : new Subject3();\n  topicMap.set(topic, messageSubject);\n  topicSubjectMap.set(room, topicMap);\n  if (needsSetup) {\n    const {\n      messageObservable\n    } = setupDataMessageHandler(room, [topic, updateTopic]);\n    messageObservable.pipe(takeUntil(onDestroyObservable)).subscribe(messageSubject);\n  }\n  const finalMessageDecoder = messageDecoder != null ? messageDecoder : decode;\n  const messagesObservable = messageSubject.pipe(map6(msg => {\n    const parsedMessage = finalMessageDecoder(msg.payload);\n    const newMessage = __spreadProps(__spreadValues({}, parsedMessage), {\n      from: msg.from\n    });\n    return newMessage;\n  }), scan((acc, value) => {\n    if (\"id\" in value && acc.find(msg => {\n      var _a2, _b2;\n      return ((_a2 = msg.from) == null ? void 0 : _a2.identity) === ((_b2 = value.from) == null ? void 0 : _b2.identity) && msg.id === value.id;\n    })) {\n      const replaceIndex = acc.findIndex(msg => msg.id === value.id);\n      if (replaceIndex > -1) {\n        const originalMsg = acc[replaceIndex];\n        acc[replaceIndex] = __spreadProps(__spreadValues({}, value), {\n          timestamp: originalMsg.timestamp,\n          editTimestamp: value.timestamp\n        });\n      }\n      return [...acc];\n    }\n    return [...acc, value];\n  }, []), takeUntil(onDestroyObservable));\n  const isSending$ = new BehaviorSubject2(false);\n  const finalMessageEncoder = messageEncoder != null ? messageEncoder : encode;\n  const send = message => __async(this, null, function* () {\n    const timestamp = Date.now();\n    const id = crypto.randomUUID();\n    const chatMessage = {\n      id,\n      message,\n      timestamp\n    };\n    const encodedMsg = finalMessageEncoder(chatMessage);\n    isSending$.next(true);\n    try {\n      yield sendMessage(room.localParticipant, encodedMsg, {\n        reliable: true,\n        topic\n      });\n      messageSubject.next({\n        payload: encodedMsg,\n        topic,\n        from: room.localParticipant\n      });\n      return chatMessage;\n    } finally {\n      isSending$.next(false);\n    }\n  });\n  const update = (message, messageId) => __async(this, null, function* () {\n    const timestamp = Date.now();\n    const chatMessage = {\n      id: messageId,\n      message,\n      timestamp\n    };\n    const encodedMsg = finalMessageEncoder(chatMessage);\n    isSending$.next(true);\n    try {\n      yield sendMessage(room.localParticipant, encodedMsg, {\n        topic: updateTopic,\n        reliable: true\n      });\n      messageSubject.next({\n        payload: encodedMsg,\n        topic,\n        from: room.localParticipant\n      });\n      return chatMessage;\n    } finally {\n      isSending$.next(false);\n    }\n  });\n  function destroy() {\n    onDestroyObservable.next();\n    onDestroyObservable.complete();\n    topicSubjectMap.clear();\n  }\n  room.once(RoomEvent4.Disconnected, destroy);\n  return {\n    messageObservable: messagesObservable,\n    isSendingObservable: isSending$,\n    send,\n    update\n  };\n}\n\n// src/components/startAudio.ts\nfunction setupStartAudio() {\n  const handleStartAudioPlayback = room => __async(this, null, function* () {\n    log.info(\"Start Audio for room: \", room);\n    yield room.startAudio();\n  });\n  const className = prefixClass(\"start-audio-button\");\n  return {\n    className,\n    roomAudioPlaybackAllowedObservable,\n    handleStartAudioPlayback\n  };\n}\n\n// src/components/startVideo.ts\nfunction setupStartVideo() {\n  const handleStartVideoPlayback = room => __async(this, null, function* () {\n    log.info(\"Start Video for room: \", room);\n    yield room.startVideo();\n  });\n  const className = prefixClass(\"start-audio-button\");\n  return {\n    className,\n    roomVideoPlaybackAllowedObservable,\n    handleStartVideoPlayback\n  };\n}\n\n// src/components/chatToggle.ts\nfunction setupChatToggle() {\n  const className = [prefixClass(\"button\"), prefixClass(\"chat-toggle\")].join(\" \");\n  return {\n    className\n  };\n}\n\n// src/components/focusToggle.ts\nfunction setupFocusToggle() {\n  const className = [prefixClass(\"button\"), prefixClass(\"focus-toggle-button\")].join(\" \");\n  return {\n    className\n  };\n}\n\n// src/components/clearPinButton.ts\nfunction setupClearPinButton() {\n  const className = \"lk-clear-pin-button lk-button\";\n  return {\n    className\n  };\n}\n\n// src/components/room.ts\nfunction setupLiveKitRoom() {\n  const className = \"lk-room-container\";\n  return {\n    className\n  };\n}\n\n// src/observables/track.ts\nimport { RoomEvent as RoomEvent5, TrackEvent } from \"livekit-client\";\nimport { map as map7, Observable as Observable4, startWith as startWith5 } from \"rxjs\";\nfunction trackObservable(track) {\n  const trackObserver = observeTrackEvents(track, TrackEvent.Muted, TrackEvent.Unmuted, TrackEvent.Subscribed, TrackEvent.Unsubscribed);\n  return trackObserver;\n}\nfunction observeTrackEvents(track, ...events) {\n  const observable = new Observable4(subscribe => {\n    const onTrackUpdate = () => {\n      subscribe.next(track);\n    };\n    events.forEach(evt => {\n      track.on(evt, onTrackUpdate);\n    });\n    const unsubscribe = () => {\n      events.forEach(evt => {\n        track.off(evt, onTrackUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith5(track));\n  return observable;\n}\nfunction getTrackReferences(room, sources, onlySubscribedTracks = true) {\n  const localParticipant = room.localParticipant;\n  const allParticipants = [localParticipant, ...Array.from(room.remoteParticipants.values())];\n  const trackReferences = [];\n  allParticipants.forEach(participant => {\n    sources.forEach(source => {\n      const sourceReferences = Array.from(participant.trackPublications.values()).filter(track => track.source === source && (\n      // either return all or only the ones that are subscribed\n      !onlySubscribedTracks || track.track)).map(track => {\n        return {\n          participant,\n          publication: track,\n          source: track.source\n        };\n      });\n      trackReferences.push(...sourceReferences);\n    });\n  });\n  return {\n    trackReferences,\n    participants: allParticipants\n  };\n}\nfunction getParticipantTrackRefs(participant, identifier, onlySubscribedTracks = false) {\n  const {\n    sources,\n    kind,\n    name\n  } = identifier;\n  const sourceReferences = Array.from(participant.trackPublications.values()).filter(pub => (!sources || sources.includes(pub.source)) && (!kind || pub.kind === kind) && (!name || pub.trackName === name) && (\n  // either return all or only the ones that are subscribed\n  !onlySubscribedTracks || pub.track)).map(track => {\n    return {\n      participant,\n      publication: track,\n      source: track.source\n    };\n  });\n  return sourceReferences;\n}\nfunction trackReferencesObservable(room, sources, options) {\n  var _a, _b;\n  const additionalRoomEvents = (_a = options.additionalRoomEvents) != null ? _a : allParticipantRoomEvents;\n  const onlySubscribedTracks = (_b = options.onlySubscribed) != null ? _b : true;\n  const roomEvents = Array.from(( /* @__PURE__ */new Set([RoomEvent5.ParticipantConnected, RoomEvent5.ParticipantDisconnected, RoomEvent5.ConnectionStateChanged, RoomEvent5.LocalTrackPublished, RoomEvent5.LocalTrackUnpublished, RoomEvent5.TrackPublished, RoomEvent5.TrackUnpublished, RoomEvent5.TrackSubscriptionStatusChanged, ...additionalRoomEvents])).values());\n  const observable = observeRoomEvents(room, ...roomEvents).pipe(map7(room2 => {\n    const data = getTrackReferences(room2, sources, onlySubscribedTracks);\n    log.debug(`TrackReference[] was updated. (length ${data.trackReferences.length})`, data);\n    return data;\n  }), startWith5(getTrackReferences(room, sources, onlySubscribedTracks)));\n  return observable;\n}\nfunction participantTracksObservable(participant, trackIdentifier) {\n  const observable = observeParticipantEvents(participant, ...participantTrackEvents).pipe(map7(participant2 => {\n    const data = getParticipantTrackRefs(participant2, trackIdentifier);\n    log.debug(`TrackReference[] was updated. (length ${data.length})`, data);\n    return data;\n  }), startWith5(getParticipantTrackRefs(participant, trackIdentifier)));\n  return observable;\n}\n\n// src/observables/dom-event.ts\nimport { concat as concat2, distinctUntilChanged, fromEvent, map as map8, of, skipUntil, timeout } from \"rxjs\";\nfunction createInteractingObservable(htmlElement, inactiveAfter = 1e3) {\n  if (htmlElement === null) return of(false);\n  const move$ = fromEvent(htmlElement, \"mousemove\", {\n    passive: true\n  }).pipe(map8(() => true));\n  const moveAndStop$ = move$.pipe(timeout({\n    each: inactiveAfter,\n    with: () => concat2(of(false), moveAndStop$.pipe(skipUntil(move$)))\n  }), distinctUntilChanged());\n  return moveAndStop$;\n}\n\n// src/persistent-storage/local-storage-helpers.ts\nfunction saveToLocalStorage(key, value) {\n  if (typeof localStorage === \"undefined\") {\n    log.error(\"Local storage is not available.\");\n    return;\n  }\n  try {\n    localStorage.setItem(key, JSON.stringify(value));\n  } catch (error) {\n    log.error(`Error setting item to local storage: ${error}`);\n  }\n}\nfunction loadFromLocalStorage(key) {\n  if (typeof localStorage === \"undefined\") {\n    log.error(\"Local storage is not available.\");\n    return void 0;\n  }\n  try {\n    const item = localStorage.getItem(key);\n    if (!item) {\n      log.warn(`Item with key ${key} does not exist in local storage.`);\n      return void 0;\n    }\n    return JSON.parse(item);\n  } catch (error) {\n    log.error(`Error getting item from local storage: ${error}`);\n    return void 0;\n  }\n}\nfunction createLocalStorageInterface(key) {\n  return {\n    load: () => loadFromLocalStorage(key),\n    save: value => saveToLocalStorage(key, value)\n  };\n}\n\n// src/persistent-storage/user-choices.ts\nvar USER_CHOICES_KEY = `${cssPrefix}-user-choices`;\nvar defaultUserChoices = {\n  videoEnabled: true,\n  audioEnabled: true,\n  videoDeviceId: \"\",\n  audioDeviceId: \"\",\n  username: \"\"\n};\nvar {\n  load,\n  save\n} = createLocalStorageInterface(USER_CHOICES_KEY);\nfunction saveUserChoices(userChoices, preventSave = false) {\n  if (preventSave === true) {\n    return;\n  }\n  save(userChoices);\n}\nfunction loadUserChoices(defaults, preventLoad = false) {\n  var _a, _b, _c, _d, _e;\n  const fallback = {\n    videoEnabled: (_a = defaults == null ? void 0 : defaults.videoEnabled) != null ? _a : defaultUserChoices.videoEnabled,\n    audioEnabled: (_b = defaults == null ? void 0 : defaults.audioEnabled) != null ? _b : defaultUserChoices.audioEnabled,\n    videoDeviceId: (_c = defaults == null ? void 0 : defaults.videoDeviceId) != null ? _c : defaultUserChoices.videoDeviceId,\n    audioDeviceId: (_d = defaults == null ? void 0 : defaults.audioDeviceId) != null ? _d : defaultUserChoices.audioDeviceId,\n    username: (_e = defaults == null ? void 0 : defaults.username) != null ? _e : defaultUserChoices.username\n  };\n  if (preventLoad) {\n    return fallback;\n  } else {\n    const maybeLoadedObject = load();\n    const result = __spreadValues(__spreadValues({}, fallback), maybeLoadedObject != null ? maybeLoadedObject : {});\n    return result;\n  }\n}\nexport { DataTopic, GRID_LAYOUTS, PIN_DEFAULT_STATE, WIDGET_DEFAULT_STATE, activeSpeakerObserver, allParticipantEvents, allParticipantRoomEvents, allRemoteParticipantEvents, allRemoteParticipantRoomEvents, attachIfSubscribed, computeMenuPosition, connectedParticipantObserver, connectedParticipantsObserver, connectionStateObserver, createActiveDeviceObservable, createConnectionQualityObserver, createDataObserver, createDefaultGrammar, createEmailRegExp, createInteractingObservable, createIsSpeakingObserver, createMediaDeviceObserver, createTrackObserver, createUrlRegExp, cssPrefix, defaultUserChoices, encryptionStatusObservable, getScrollBarWidth, getTrackByIdentifier, getTrackReferenceId, getTrackReferenceSource, isEqualTrackRef, isLocal, isMobileBrowser, isParticipantTrackReferencePinned, isPlaceholderReplacement, isRemote, isSourceWitOptions, isSourcesWithOptions, isTrackReference, isTrackReferencePinned, isTrackReferencePlaceholder, isWeb, loadUserChoices, log, mutedObserver, observeParticipantEvents, observeParticipantMedia, observeRoomEvents, observeTrackEvents, participantEventSelector, participantInfoObserver, participantPermissionObserver, participantTrackEvents, participantTracksObservable, roomAudioPlaybackAllowedObservable, roomEventSelector, roomInfoObserver, roomObserver, roomVideoPlaybackAllowedObservable, saveUserChoices, screenShareObserver, selectGridLayout, sendMessage, setDifference, setLogExtension, setLogLevel, setupChat, setupChatToggle, setupClearPinButton, setupConnectionQualityIndicator, setupDataMessageHandler, setupDeviceSelector, setupDisconnectButton, setupFocusToggle, setupLiveKitRoom, setupManualToggle, setupMediaToggle, setupMediaTrack, setupParticipantName, setupParticipantTile, setupStartAudio, setupStartVideo, setupTrackMutedIndicator, sortParticipants, sortTrackReferences, supportsScreenSharing, tokenize, trackObservable, trackReferencesObservable, updatePages, wasClickOutside };","map":{"version":3,"names":["cssPrefix","LocalParticipant","RemoteParticipant","isTrackReference","trackReference","isTrackReferenceSubscribed","isTrackReferencePublished","_a","hasOwnProperty","publication","track","isTrackReferencePlaceholder","getTrackReferenceId","participant","identity","source","trackSid","Error","getTrackReferenceSource","isEqualTrackRef","a","b","isTrackReferencePinned","pinState","some","pinnedTrackReference","isPlaceholderReplacement","currentTrackRef","nextTrackRef","isLocal","p","isRemote","attachIfSubscribed","element","isSubscribed","attach","detach","isParticipantTrackReferencePinned","trackRef","pinnedTrackRef","getScrollBarWidth","inner","document","createElement","style","width","height","outer","position","top","left","visibility","overflow","appendChild","body","w1","offsetWidth","w2","clientWidth","removeChild","scrollBarWidth","isWeb","isMobileBrowser","test","window","navigator","userAgent","createUrlRegExp","options","__spreadValues","protocol","auth","ip","RegExp","host","domain","tld","port","path","regex","exact","createEmailRegExp","computePosition","flip","offset","shift","computeMenuPosition","button","menu","__async","x","y","placement","middleware","padding","wasClickOutside","insideElement","event","isOutside","contains","target","createDefaultGrammar","email","url","tokenize","input","grammar","matches","Object","entries","map","type","rx","weight","Array","from","matchAll","index","content","flat","sort","d","filter","i","arr","prev","length","tokens","pos","push","substring","ParticipantEvent","RoomEvent","allRemoteParticipantRoomEvents","ConnectionStateChanged","RoomMetadataChanged","ActiveSpeakersChanged","ConnectionQualityChanged","ParticipantConnected","ParticipantDisconnected","ParticipantPermissionsChanged","ParticipantMetadataChanged","TrackMuted","TrackUnmuted","TrackPublished","TrackUnpublished","TrackStreamStateChanged","TrackSubscriptionFailed","TrackSubscriptionPermissionChanged","TrackSubscriptionStatusChanged","allParticipantRoomEvents","LocalTrackPublished","LocalTrackUnpublished","participantTrackEvents","TrackSubscribed","TrackUnsubscribed","allRemoteParticipantEvents","IsSpeakingChanged","allParticipantEvents","setLogLevel","setClientSdkLogLevel","setLogExtension","setClientSdkLogExtension","LogLevel","LogLevelEnum","loglevel","log","getLogger","setDefaultLevel","level","setLevel","liveKitClientLogLevel","extension","originalFactory","methodFactory","methodName","configLevel","loggerName","rawMethod","logLevel","needLog","silent","msg","context","getLevel","liveKitClientLogExtension","GRID_LAYOUTS","columns","rows","name","minTiles","maxTiles","minWidth","minHeight","selectGridLayout","layouts","participantCount","currentLayoutIndex","layout","find","layout_","allLayouts","isBiggerLayoutAvailable","findIndex","l","layoutIsBiggerThanCurrent","layoutFitsSameAmountOfParticipants","warn","smallerLayout","slice","setDifference","setA","setB","_difference","Set","elem","delete","supportsScreenSharing","mediaDevices","getDisplayMedia","PIN_DEFAULT_STATE","WIDGET_DEFAULT_STATE","showChat","unreadMessages","showSettings","isSourceWitOptions","isSourcesWithOptions","sources","isArray","Track","Track2","sortParticipantsByAudioLevel","audioLevel","sortParticipantsByIsSpeaking","isSpeaking","sortParticipantsByLastSpokenAT","_b","_c","_d","lastSpokeAt","getTime","sortParticipantsByJoinedAt","joinedAt","sortTrackReferencesByType","sortTrackRefsByIsCameraEnabled","aVideo","isCameraEnabled","bVideo","sortTrackReferences","tracks","localTracks","screenShareTracks","cameraTracks","undefinedTracks","forEach","Source","Camera","ScreenShare","sortedScreenShareTracks","sortScreenShareTracks","sortedCameraTracks","sortCameraTracks","localScreenShares","remoteScreenShares","sortedScreenShareTrackRefs","cameraTrackReferences","localCameraTracks","remoteCameraTracks","LocalParticipant2","sortParticipants","participants","sortedParticipants","videoTrackPublications","size","localParticipant","localIdx","indexOf","splice","chunk","reduce","item","idx","zip","a1","a2","resultLength","Math","max","fill","_val","differenceBy","by","c","v","includes","Participant","Track3","TrackPublication","flatTrackReferenceArray","list","visualPageChange","state","next","dropped","added","listNeedsUpdating","changes","trackReferences","indexToReplace","trackReference_","swapItems","moveForward","moveBack","indexReplaceWith","dropItem","itemToDrop","indexOfElementToDrop","addItem","itemToAdd","divideIntoPages","maxElementsOnPage","pages","updatePages","currentList","nextList","maxItemsOnPage","updatedList","refreshList","addedItems","currentPages","nextPages","currentPage","nextPage","pageIndex","updatedPage","debug","missingItems","currentItem","updateForCurrentItem","newItem_","Track7","Subject","Subject2","map4","startWith","startWith4","ParticipantEvent2","RoomEvent3","Track6","Observable","Observable2","map3","startWith3","switchMap","Track4","prefixClass","unprefixedClassName","setupMediaTrack","trackIdentifier","initialPub","getTrackByIdentifier","trackObserver","observeParticipantMedia","pipe","className","getTrackPublications","pub","trackName","getTrackPublicationByName","getTrackPublication","map2","startWith2","finalize","concat","LocalParticipant3","Room","RoomEvent2","Track5","observeRoomEvents","room","events","observable","subscribe","onRoomUpdate","evt","on","unsubscribe","off","roomEventSelector","update","params","roomObserver","AudioPlaybackStatusChanged","connectionStateObserver","connectionState","screenShareObserver","screenShareSubscriber","observers","subscriber","observer","handleSub","ScreenShareAudio","trackMap","tr","getScreenShareTracks","participant2","args","setTimeout","remoteParticipants","values","roomInfoObserver","r","metadata","activeSpeakerObserver","speakers","createMediaDeviceObserver","kind","onError","requestPermissions","onDeviceChange","newDevices","getLocalDevices","deviceSubject","e","_a2","removeEventListener","isSecureContext","addEventListener","catch","createDataObserver","DataReceived","roomAudioPlaybackAllowedObservable","room2","canPlayAudio","canPlaybackAudio","roomVideoPlaybackAllowedObservable","VideoPlaybackStatusChanged","canPlayVideo","canPlaybackVideo","createActiveDeviceObservable","ActiveDeviceChanged","kindOfDevice","kind2","deviceId","getActiveDevice","encryptionStatusObservable","ParticipantEncryptionStatusChanged","encrypted","isE2EEEnabled","isEncrypted","observeParticipantEvents","onParticipantUpdate","participantObserver","MediaDevicesError","isMicrophoneEnabled","isScreenShareEnabled","microphoneTrack","Microphone","cameraTrack","participantMedia","createTrackObserver","participantInfoObserver","createConnectionQualityObserver","participantEventSelector","quality","connectionQuality","mutedObserver","_b2","isMuted","createIsSpeakingObserver","connectedParticipantsObserver","sub","listener","additionalRoomEvents","roomEvents","connectedParticipantObserver","additionalEvents","getParticipantByIdentity","participantPermissionObserver","permissions","setupMediaToggle","getSourceEnabled","source2","localParticipant2","isEnabled","enabledObserver","media","pendingSubject","toggle","forceState","captureOptions","setCameraEnabled","setMicrophoneEnabled","setScreenShareEnabled","pendingObserver","asObservable","setupManualToggle","enabledSubject","Track8","BehaviorSubject","setupDeviceSelector","localTrack","activeDeviceSubject","activeDeviceObservable","setActiveMediaDevice","_0","_1","id","switchActiveDevice","actualDeviceId","info","targetTrack","useDefault","mediaStreamTrack","label","startsWith","setDeviceId","actualId","getDeviceId","value","setupDisconnectButton","disconnect","stopTracks","setupConnectionQualityIndicator","connectionQualityObserver","Track9","setupTrackMutedIndicator","classForSource","mediaMutedObserver","setupParticipantName","infoObserver","setupParticipantTile","RoomEvent4","BehaviorSubject2","Subject3","scan","map6","takeUntil","Observable3","filter2","map5","DataTopic","CHAT","CHAT_UPDATE","sendMessage","arguments","payload","reliable","destinationIdentities","topic","publishData","setupDataMessageHandler","onMessage","topics","messageObservable","messageTopic","isSendingSubscriber","isSendingObservable","send","encoder","TextEncoder","decoder","TextDecoder","topicSubjectMap","Map","encode","message","JSON","stringify","decode","parse","setupChat","onDestroyObservable","messageDecoder","messageEncoder","channelTopic","updateChannelTopic","updateTopic","needsSetup","has","topicMap","get","messageSubject","set","finalMessageDecoder","messagesObservable","parsedMessage","newMessage","__spreadProps","acc","replaceIndex","originalMsg","timestamp","editTimestamp","isSending$","finalMessageEncoder","Date","now","crypto","randomUUID","chatMessage","encodedMsg","messageId","destroy","complete","clear","once","Disconnected","setupStartAudio","handleStartAudioPlayback","startAudio","setupStartVideo","handleStartVideoPlayback","startVideo","setupChatToggle","join","setupFocusToggle","setupClearPinButton","setupLiveKitRoom","RoomEvent5","TrackEvent","map7","Observable4","startWith5","trackObservable","observeTrackEvents","Muted","Unmuted","Subscribed","Unsubscribed","onTrackUpdate","getTrackReferences","onlySubscribedTracks","allParticipants","sourceReferences","trackPublications","getParticipantTrackRefs","identifier","trackReferencesObservable","onlySubscribed","data","participantTracksObservable","concat2","distinctUntilChanged","fromEvent","map8","of","skipUntil","timeout","createInteractingObservable","htmlElement","inactiveAfter","move$","passive","moveAndStop$","each","with","saveToLocalStorage","key","localStorage","error","setItem","loadFromLocalStorage","getItem","createLocalStorageInterface","load","save","USER_CHOICES_KEY","defaultUserChoices","videoEnabled","audioEnabled","videoDeviceId","audioDeviceId","username","saveUserChoices","userChoices","preventSave","loadUserChoices","defaults","preventLoad","_e","fallback","maybeLoadedObject","result"],"sources":["C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\constants.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\utils.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\track-reference\\track-reference.types.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\track-reference\\track-reference.utils.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\helper\\detectMobileBrowser.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\helper\\url-regex.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\helper\\emailRegex.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\helper\\floating-menu.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\helper\\tokenizer.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\helper\\eventGroups.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\logger.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\helper\\grid-layouts.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\helper\\set-helper.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\helper\\featureDetection.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\types.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\sorting\\sort-track-bundles.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\sorting\\base-sort-functions.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\sorting\\sort-participants.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\helper\\array-helper.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\track-reference\\test-utils.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\sorting\\tile-array-update.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\mediaToggle.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\observables\\participant.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\mediaTrack.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\styles-interface\\class-prefixer.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\observables\\room.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\mediaDeviceSelect.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\disconnectButton.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\connectionQualityIndicator.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\trackMutedIndicator.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\participantName.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\participantTile.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\chat.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\observables\\dataChannel.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\startAudio.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\startVideo.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\chatToggle.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\focusToggle.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\clearPinButton.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\room.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\observables\\track.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\observables\\dom-event.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\persistent-storage\\local-storage-helpers.ts","C:\\Users\\brayd\\Documents\\ALL COLLEGE PROGRAMS\\comp231-007-Team-2-W24-\\comp231-007-Team-2-W24-\\frontend\\node_modules\\@livekit\\components-core\\src\\persistent-storage\\user-choices.ts"],"sourcesContent":["export const cssPrefix = 'lk';\n","import type { Participant, TrackPublication } from 'livekit-client';\nimport { LocalParticipant, RemoteParticipant } from 'livekit-client';\n\nimport type { PinState } from './types';\nimport type { TrackReference } from './track-reference';\nimport { isEqualTrackRef } from './track-reference';\n\nexport function isLocal(p: Participant) {\n  return p instanceof LocalParticipant;\n}\n\nexport function isRemote(p: Participant) {\n  return p instanceof RemoteParticipant;\n}\n\nexport const attachIfSubscribed = (\n  publication: TrackPublication | undefined,\n  element: HTMLMediaElement | null | undefined,\n) => {\n  if (!publication) return;\n  const { isSubscribed, track } = publication;\n  if (element && track) {\n    if (isSubscribed) {\n      track.attach(element);\n    } else {\n      track.detach(element);\n    }\n  }\n};\n\n/**\n * Check if the participant track reference is pinned.\n */\nexport function isParticipantTrackReferencePinned(\n  trackRef: TrackReference,\n  pinState: PinState | undefined,\n): boolean {\n  if (pinState === undefined) {\n    return false;\n  }\n\n  return pinState.some((pinnedTrackRef) => isEqualTrackRef(pinnedTrackRef, trackRef));\n}\n\n/**\n * Calculates the scrollbar width by creating two HTML elements\n * and messaging the difference.\n * @internal\n */\nexport function getScrollBarWidth() {\n  const inner = document.createElement('p');\n  inner.style.width = '100%';\n  inner.style.height = '200px';\n\n  const outer = document.createElement('div');\n  outer.style.position = 'absolute';\n  outer.style.top = '0px';\n  outer.style.left = '0px';\n  outer.style.visibility = 'hidden';\n  outer.style.width = '200px';\n  outer.style.height = '150px';\n  outer.style.overflow = 'hidden';\n  outer.appendChild(inner);\n\n  document.body.appendChild(outer);\n  const w1 = inner.offsetWidth;\n  outer.style.overflow = 'scroll';\n  let w2 = inner.offsetWidth;\n  if (w1 === w2) {\n    w2 = outer.clientWidth;\n  }\n  document.body.removeChild(outer);\n  const scrollBarWidth = w1 - w2;\n  return scrollBarWidth;\n}\n","/**\n * The TrackReference type is a logical grouping of participant publication and/or subscribed track.\n *\n */\n\nimport type { Participant, Track, TrackPublication } from 'livekit-client';\n// ## TrackReference Types\n\n/** @public */\nexport type TrackReferencePlaceholder = {\n  participant: Participant;\n  publication?: never;\n  source: Track.Source;\n};\n\n/** @public */\nexport type TrackReference = {\n  participant: Participant;\n  publication: TrackPublication;\n  source: Track.Source;\n};\n\n/** @public */\nexport type TrackReferenceOrPlaceholder = TrackReference | TrackReferencePlaceholder;\n\n// ### TrackReference Type Predicates\n/** @internal */\nexport function isTrackReference(trackReference: unknown): trackReference is TrackReference {\n  if (typeof trackReference === 'undefined') {\n    return false;\n  }\n  return (\n    isTrackReferenceSubscribed(trackReference as TrackReference) ||\n    isTrackReferencePublished(trackReference as TrackReference)\n  );\n}\n\nfunction isTrackReferenceSubscribed(trackReference?: TrackReferenceOrPlaceholder): boolean {\n  if (!trackReference) {\n    return false;\n  }\n  return (\n    trackReference.hasOwnProperty('participant') &&\n    trackReference.hasOwnProperty('source') &&\n    trackReference.hasOwnProperty('track') &&\n    typeof trackReference.publication?.track !== 'undefined'\n  );\n}\n\nfunction isTrackReferencePublished(trackReference?: TrackReferenceOrPlaceholder): boolean {\n  if (!trackReference) {\n    return false;\n  }\n  return (\n    trackReference.hasOwnProperty('participant') &&\n    trackReference.hasOwnProperty('source') &&\n    trackReference.hasOwnProperty('publication') &&\n    typeof trackReference.publication !== 'undefined'\n  );\n}\n\nexport function isTrackReferencePlaceholder(\n  trackReference?: TrackReferenceOrPlaceholder,\n): trackReference is TrackReferencePlaceholder {\n  if (!trackReference) {\n    return false;\n  }\n  return (\n    trackReference.hasOwnProperty('participant') &&\n    trackReference.hasOwnProperty('source') &&\n    typeof trackReference.publication === 'undefined'\n  );\n}\n","import type { Track } from 'livekit-client';\nimport type { PinState } from '../types';\nimport type { TrackReferenceOrPlaceholder } from './track-reference.types';\nimport { isTrackReference, isTrackReferencePlaceholder } from './track-reference.types';\n\n/**\n * Returns a id to identify the `TrackReference` or `TrackReferencePlaceholder` based on\n * participant, track source and trackSid.\n * @remarks\n * The id pattern is: `${participantIdentity}_${trackSource}_${trackSid}` for `TrackReference`\n * and `${participantIdentity}_${trackSource}_placeholder` for `TrackReferencePlaceholder`.\n */\nexport function getTrackReferenceId(trackReference: TrackReferenceOrPlaceholder | number) {\n  if (typeof trackReference === 'string' || typeof trackReference === 'number') {\n    return `${trackReference}`;\n  } else if (isTrackReferencePlaceholder(trackReference)) {\n    return `${trackReference.participant.identity}_${trackReference.source}_placeholder`;\n  } else if (isTrackReference(trackReference)) {\n    return `${trackReference.participant.identity}_${trackReference.publication.source}_${trackReference.publication.trackSid}`;\n  } else {\n    throw new Error(`Can't generate a id for the given track reference: ${trackReference}`);\n  }\n}\n\nexport type TrackReferenceId = ReturnType<typeof getTrackReferenceId>;\n\n/** Returns the Source of the TrackReference. */\nexport function getTrackReferenceSource(trackReference: TrackReferenceOrPlaceholder): Track.Source {\n  if (isTrackReference(trackReference)) {\n    return trackReference.publication.source;\n  } else {\n    return trackReference.source;\n  }\n}\n\nexport function isEqualTrackRef(\n  a?: TrackReferenceOrPlaceholder,\n  b?: TrackReferenceOrPlaceholder,\n): boolean {\n  if (a === undefined || b === undefined) {\n    return false;\n  }\n  if (isTrackReference(a) && isTrackReference(b)) {\n    return a.publication.trackSid === b.publication.trackSid;\n  } else {\n    return getTrackReferenceId(a) === getTrackReferenceId(b);\n  }\n}\n\n/**\n * Check if the `TrackReference` is pinned.\n */\nexport function isTrackReferencePinned(\n  trackReference: TrackReferenceOrPlaceholder,\n  pinState: PinState | undefined,\n): boolean {\n  if (typeof pinState === 'undefined') {\n    return false;\n  }\n  if (isTrackReference(trackReference)) {\n    return pinState.some(\n      (pinnedTrackReference) =>\n        pinnedTrackReference.participant.identity === trackReference.participant.identity &&\n        isTrackReference(pinnedTrackReference) &&\n        pinnedTrackReference.publication.trackSid === trackReference.publication.trackSid,\n    );\n  } else if (isTrackReferencePlaceholder(trackReference)) {\n    return pinState.some(\n      (pinnedTrackReference) =>\n        pinnedTrackReference.participant.identity === trackReference.participant.identity &&\n        isTrackReferencePlaceholder(pinnedTrackReference) &&\n        pinnedTrackReference.source === trackReference.source,\n    );\n  } else {\n    return false;\n  }\n}\n\n/**\n * Check if the current `currentTrackRef` is the placeholder for next `nextTrackRef`.\n * Based on the participant identity and the source.\n * @internal\n */\nexport function isPlaceholderReplacement(\n  currentTrackRef: TrackReferenceOrPlaceholder,\n  nextTrackRef: TrackReferenceOrPlaceholder,\n) {\n  // if (typeof nextTrackRef === 'number' || typeof currentTrackRef === 'number') {\n  //   return false;\n  // }\n  return (\n    isTrackReferencePlaceholder(currentTrackRef) &&\n    isTrackReference(nextTrackRef) &&\n    nextTrackRef.participant.identity === currentTrackRef.participant.identity &&\n    nextTrackRef.source === currentTrackRef.source\n  );\n}\n","/**\n * @internal\n */\nexport function isWeb(): boolean {\n  return typeof document !== 'undefined';\n}\n\n/**\n * Mobile browser detection based on `navigator.userAgent` string.\n * Defaults to returning `false` if not in a browser.\n *\n * @remarks\n * This should only be used if feature detection or other methods do not work!\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#mobile_device_detection\n */\nexport function isMobileBrowser(): boolean {\n  return isWeb() ? /Mobi/i.test(window.navigator.userAgent) : false;\n}\n","// The MIT License (MIT)\n\n// Copyright (c) Kevin Mårtensson <kevinmartensson@gmail.com> and Diego Perini\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\ninterface RegExOptions {\n  /**\n\t\tOnly match an exact string. Useful with `RegExp#test` to check if a string is a URL.\n\t\t@defaultValue false\n\t\t*/\n  readonly exact?: boolean;\n}\n\nexport function createUrlRegExp(options: RegExOptions) {\n  options = {\n    ...options,\n  };\n\n  const protocol = `(?:(?:[a-z]+:)?//)?`;\n  const auth = '(?:\\\\S+(?::\\\\S*)?@)?';\n  const ip = new RegExp(\n    '(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}',\n    'g',\n  ).source;\n  const host = '(?:(?:[a-z\\\\u00a1-\\\\uffff0-9][-_]*)*[a-z\\\\u00a1-\\\\uffff0-9]+)';\n  const domain = '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*';\n  const tld = `(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\\\\.?`;\n  const port = '(?::\\\\d{2,5})?';\n  const path = '(?:[/?#][^\\\\s\"]*)?';\n  const regex = `(?:${protocol}|www\\\\.)${auth}(?:localhost|${ip}|${host}${domain}${tld})${port}${path}`;\n\n  return options.exact ? new RegExp(`(?:^${regex}$)`, 'i') : new RegExp(regex, 'ig');\n}\n","import createEmailRegExp from 'email-regex';\n\nexport { createEmailRegExp };\n","import { computePosition, flip, offset, shift } from '@floating-ui/dom';\n\nexport async function computeMenuPosition(\n  button: HTMLElement,\n  menu: HTMLElement,\n): Promise<{ x: number; y: number }> {\n  const { x, y } = await computePosition(button, menu, {\n    placement: 'top',\n    middleware: [offset(6), flip(), shift({ padding: 5 })],\n  });\n  return { x, y };\n}\n\nexport function wasClickOutside(insideElement: HTMLElement, event: MouseEvent): boolean {\n  const isOutside = !insideElement.contains(event.target as Node);\n  return isOutside;\n}\n","import { createEmailRegExp } from './emailRegex';\nimport { createUrlRegExp } from './url-regex';\n\nexport type TokenizeGrammar = { [type: string]: RegExp };\n\nexport const createDefaultGrammar = () => {\n  return {\n    email: createEmailRegExp(),\n    url: createUrlRegExp({}),\n  } satisfies TokenizeGrammar;\n};\n\nexport function tokenize<T extends TokenizeGrammar>(input: string, grammar: T) {\n  const matches = Object.entries(grammar)\n    .map(([type, rx], weight) =>\n      Array.from(input.matchAll(rx)).map(({ index, 0: content }) => ({\n        type: type as keyof T,\n        weight,\n        content,\n        index: index ?? 0,\n      })),\n    )\n    .flat()\n    .sort((a, b) => {\n      const d = a.index - b.index;\n      return d !== 0 ? d : a.weight - b.weight;\n    })\n    .filter(({ index }, i, arr) => {\n      if (i === 0) return true;\n      const prev = arr[i - 1];\n      return prev.index + prev.content.length <= index;\n    });\n\n  const tokens = [];\n  let pos = 0;\n  for (const { type, content, index } of matches) {\n    if (index > pos) tokens.push(input.substring(pos, index));\n    tokens.push({ type, content });\n    pos = index + content.length;\n  }\n  if (input.length > pos) tokens.push(input.substring(pos));\n  return tokens;\n}\n","import { ParticipantEvent, RoomEvent } from 'livekit-client';\n\nexport const allRemoteParticipantRoomEvents = [\n  RoomEvent.ConnectionStateChanged,\n  RoomEvent.RoomMetadataChanged,\n\n  RoomEvent.ActiveSpeakersChanged,\n  RoomEvent.ConnectionQualityChanged,\n\n  RoomEvent.ParticipantConnected,\n  RoomEvent.ParticipantDisconnected,\n  RoomEvent.ParticipantPermissionsChanged,\n  RoomEvent.ParticipantMetadataChanged,\n\n  RoomEvent.TrackMuted,\n  RoomEvent.TrackUnmuted,\n  RoomEvent.TrackPublished,\n  RoomEvent.TrackUnpublished,\n  RoomEvent.TrackStreamStateChanged,\n  RoomEvent.TrackSubscriptionFailed,\n  RoomEvent.TrackSubscriptionPermissionChanged,\n  RoomEvent.TrackSubscriptionStatusChanged,\n];\n\nexport const allParticipantRoomEvents = [\n  ...allRemoteParticipantRoomEvents,\n  RoomEvent.LocalTrackPublished,\n  RoomEvent.LocalTrackUnpublished,\n];\n\nexport const participantTrackEvents = [\n  ParticipantEvent.TrackPublished,\n  ParticipantEvent.TrackUnpublished,\n  ParticipantEvent.TrackMuted,\n  ParticipantEvent.TrackUnmuted,\n  ParticipantEvent.TrackStreamStateChanged,\n  ParticipantEvent.TrackSubscribed,\n  ParticipantEvent.TrackUnsubscribed,\n  ParticipantEvent.TrackSubscriptionPermissionChanged,\n  ParticipantEvent.TrackSubscriptionFailed,\n  ParticipantEvent.LocalTrackPublished,\n  ParticipantEvent.LocalTrackUnpublished,\n];\n\nexport const allRemoteParticipantEvents = [\n  ParticipantEvent.ConnectionQualityChanged,\n  ParticipantEvent.IsSpeakingChanged,\n  ParticipantEvent.ParticipantMetadataChanged,\n  ParticipantEvent.ParticipantPermissionsChanged,\n\n  ParticipantEvent.TrackMuted,\n  ParticipantEvent.TrackUnmuted,\n  ParticipantEvent.TrackPublished,\n  ParticipantEvent.TrackUnpublished,\n  ParticipantEvent.TrackStreamStateChanged,\n  ParticipantEvent.TrackSubscriptionFailed,\n  ParticipantEvent.TrackSubscriptionPermissionChanged,\n  ParticipantEvent.TrackSubscriptionStatusChanged,\n];\n\nexport const allParticipantEvents = [\n  ...allRemoteParticipantEvents,\n  ParticipantEvent.LocalTrackPublished,\n  ParticipantEvent.LocalTrackUnpublished,\n];\n","import {\n  setLogLevel as setClientSdkLogLevel,\n  setLogExtension as setClientSdkLogExtension,\n  LogLevel as LogLevelEnum,\n} from 'livekit-client';\nimport loglevel from 'loglevel';\n\nexport const log = loglevel.getLogger('lk-components-js');\nlog.setDefaultLevel('WARN');\n\ntype LogLevel = Parameters<typeof setClientSdkLogLevel>[0];\ntype SetLogLevelOptions = {\n  liveKitClientLogLevel?: LogLevel;\n};\n\n/**\n * Set the log level for both the `@livekit/components-react` package and the `@livekit-client` package.\n * To set the `@livekit-client` log independently, use the `liveKitClientLogLevel` prop on the `options` object.\n * @public\n */\nexport function setLogLevel(level: LogLevel, options: SetLogLevelOptions = {}): void {\n  log.setLevel(level);\n  setClientSdkLogLevel(options.liveKitClientLogLevel ?? level);\n}\n\ntype LogExtension = (level: LogLevel, msg: string, context?: object) => void;\ntype SetLogExtensionOptions = {\n  liveKitClientLogExtension?: LogExtension;\n};\n\n/**\n * Set the log extension for both the `@livekit/components-react` package and the `@livekit-client` package.\n * To set the `@livekit-client` log extension, use the `liveKitClientLogExtension` prop on the `options` object.\n * @public\n */\nexport function setLogExtension(extension: LogExtension, options: SetLogExtensionOptions = {}) {\n  const originalFactory = log.methodFactory;\n\n  log.methodFactory = (methodName, configLevel, loggerName) => {\n    const rawMethod = originalFactory(methodName, configLevel, loggerName);\n\n    const logLevel = LogLevelEnum[methodName];\n    const needLog = logLevel >= configLevel && logLevel < LogLevelEnum.silent;\n\n    return (msg, context?: [msg: string, context: object]) => {\n      if (context) rawMethod(msg, context);\n      else rawMethod(msg);\n      if (needLog) {\n        extension(logLevel, msg, context);\n      }\n    };\n  };\n  log.setLevel(log.getLevel()); // Be sure to call setLevel method in order to apply plugin\n  setClientSdkLogExtension(options.liveKitClientLogExtension ?? extension);\n}\n","import { log } from '../logger';\n\nexport type GridLayoutDefinition = {\n  /** Layout name (convention `<column_count>x<row_count>`). */\n  name: string;\n  /** Column count of the layout. */\n  columns: number;\n  /** Row count of the layout. */\n  rows: number;\n  // # Constraints that have to be meet to use this layout.\n  // ## 1. Participant range:\n  /** Minimum number of tiles needed to use this layout. */\n  minTiles: number;\n  /** Maximum tiles that fit into this layout. */\n  maxTiles: number;\n  // ## 2. Screen size limits:\n  /** Minimum width required to use this layout. */\n  minWidth: number;\n  /** Minimum height required to use this layout. */\n  minHeight: number;\n};\n\nexport const GRID_LAYOUTS: GridLayoutDefinition[] = [\n  {\n    columns: 1,\n    rows: 1,\n    name: '1x1',\n    minTiles: 1,\n    maxTiles: 1,\n    minWidth: 0,\n    minHeight: 0,\n  },\n  {\n    columns: 1,\n    rows: 2,\n    name: '1x2',\n    minTiles: 2,\n    maxTiles: 2,\n    minWidth: 0,\n    minHeight: 0,\n  },\n  {\n    columns: 2,\n    rows: 1,\n    name: '2x1',\n    minTiles: 2,\n    maxTiles: 2,\n    minWidth: 900,\n    minHeight: 0,\n  },\n  {\n    columns: 2,\n    rows: 2,\n    name: '2x2',\n    minTiles: 3,\n    maxTiles: 4,\n    minWidth: 560,\n    minHeight: 0,\n  },\n  {\n    columns: 3,\n    rows: 3,\n    name: '3x3',\n    minTiles: 5,\n    maxTiles: 9,\n    minWidth: 700,\n    minHeight: 0,\n  },\n  {\n    columns: 4,\n    rows: 4,\n    name: '4x4',\n    minTiles: 10,\n    maxTiles: 16,\n    minWidth: 960,\n    minHeight: 0,\n  },\n  {\n    columns: 5,\n    rows: 5,\n    name: '5x5',\n    minTiles: 17,\n    maxTiles: 25,\n    minWidth: 1100,\n    minHeight: 0,\n  },\n];\n\nexport function selectGridLayout(\n  layouts: GridLayoutDefinition[],\n  participantCount: number,\n  width: number,\n  height: number,\n): GridLayoutDefinition {\n  // Find the best layout to fit all participants.\n  let currentLayoutIndex = 0;\n  let layout = layouts.find((layout_, index, allLayouts) => {\n    currentLayoutIndex = index;\n    const isBiggerLayoutAvailable =\n      allLayouts.findIndex((l, i) => {\n        const layoutIsBiggerThanCurrent = i > index;\n        const layoutFitsSameAmountOfParticipants = l.maxTiles === layout_.maxTiles;\n        return layoutIsBiggerThanCurrent && layoutFitsSameAmountOfParticipants;\n      }) !== -1;\n    return layout_.maxTiles >= participantCount && !isBiggerLayoutAvailable;\n  });\n  if (layout === undefined) {\n    layout = layouts[layouts.length - 1];\n    if (layout) {\n      log.warn(\n        `No layout found for: participantCount: ${participantCount}, width/height: ${width}/${height} fallback to biggest available layout (${layout.name}).`,\n      );\n    } else {\n      throw new Error(`No layout or fallback layout found.`);\n    }\n  }\n\n  // Check if the layout fits into the screen constraints. If not, recursively check the next smaller layout.\n  if (width < layout.minWidth || height < layout.minHeight) {\n    // const currentLayoutIndex = layouts.indexOf(layout);\n    if (currentLayoutIndex > 0) {\n      const smallerLayout = layouts[currentLayoutIndex - 1];\n      layout = selectGridLayout(\n        layouts.slice(0, currentLayoutIndex),\n        smallerLayout.maxTiles,\n        width,\n        height,\n      );\n    }\n  }\n  return layout;\n}\n","export function setDifference<T>(setA: Set<T>, setB: Set<T>): Set<T> {\n  const _difference = new Set(setA);\n  for (const elem of setB) {\n    _difference.delete(elem);\n  }\n  return _difference;\n}\n","/**\n * Returns `true` if the browser supports screen sharing.\n */\nexport function supportsScreenSharing(): boolean {\n  return (\n    typeof navigator !== 'undefined' &&\n    navigator.mediaDevices &&\n    !!navigator.mediaDevices.getDisplayMedia\n  );\n}\n","import type { Participant, Track, TrackPublication } from 'livekit-client';\nimport type { TrackReference, TrackReferenceOrPlaceholder } from './track-reference';\n\n// ## PinState Type\n/** @public */\nexport type PinState = TrackReferenceOrPlaceholder[];\nexport const PIN_DEFAULT_STATE: PinState = [];\n\n// ## WidgetState Types\n/** @public */\nexport type WidgetState = {\n  showChat: boolean;\n  unreadMessages: number;\n  showSettings?: boolean;\n};\nexport const WIDGET_DEFAULT_STATE: WidgetState = {\n  showChat: false,\n  unreadMessages: 0,\n  showSettings: false,\n};\n\n// ## Track Source Types\nexport type TrackSourceWithOptions = { source: Track.Source; withPlaceholder: boolean };\n\nexport type SourcesArray = Track.Source[] | TrackSourceWithOptions[];\n\n// ### Track Source Type Predicates\nexport function isSourceWitOptions(source: SourcesArray[number]): source is TrackSourceWithOptions {\n  return typeof source === 'object';\n}\n\nexport function isSourcesWithOptions(sources: SourcesArray): sources is TrackSourceWithOptions[] {\n  return (\n    Array.isArray(sources) &&\n    (sources as TrackSourceWithOptions[]).filter(isSourceWitOptions).length > 0\n  );\n}\n\n// ## Loop Filter Types\nexport type TrackReferenceFilter = Parameters<TrackReferenceOrPlaceholder[]['filter']>['0'];\nexport type ParticipantFilter = Parameters<Participant[]['filter']>['0'];\n\n// ## Other Types\n/** @internal */\nexport interface ParticipantClickEvent {\n  participant: Participant;\n  track?: TrackPublication;\n}\n\nexport type TrackSource<T extends Track.Source> = RequireAtLeastOne<\n  { source: T; name: string; participant: Participant },\n  'name' | 'source'\n>;\n\nexport type ParticipantTrackIdentifier = RequireAtLeastOne<\n  { sources: Track.Source[]; name: string; kind: Track.Kind },\n  'sources' | 'name' | 'kind'\n>;\n\n/**\n * The TrackIdentifier type is used to select Tracks either based on\n * - Track.Source and/or name of the track, e.g. `{source: Track.Source.Camera}` or `{name: \"my-track\"}`\n * - TrackReference (participant and publication)\n * @internal\n */\nexport type TrackIdentifier<T extends Track.Source = Track.Source> =\n  | TrackSource<T>\n  | TrackReference;\n\n// ## Util Types\ntype RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> &\n  {\n    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;\n  }[Keys];\n\nexport type RequireOnlyOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> &\n  {\n    [K in Keys]-?: Required<Pick<T, K>> & Partial<Record<Exclude<Keys, K>, undefined>>;\n  }[Keys];\n\nexport type AudioSource = Track.Source.Microphone | Track.Source.ScreenShareAudio;\nexport type VideoSource = Track.Source.Camera | Track.Source.ScreenShare;\n","import { Track } from 'livekit-client';\nimport type { TrackReferenceOrPlaceholder } from '../track-reference';\nimport { isTrackReference } from '../track-reference';\nimport {\n  sortParticipantsByAudioLevel,\n  sortParticipantsByIsSpeaking,\n  sortParticipantsByJoinedAt,\n  sortParticipantsByLastSpokenAT,\n  sortTrackReferencesByType,\n  sortTrackRefsByIsCameraEnabled,\n} from './base-sort-functions';\n\n/**\n * Default sort for `TrackReferenceOrPlaceholder`, it'll order participants by:\n * 1. local camera track (publication.isLocal)\n * 2. remote screen_share track\n * 3. local screen_share track\n * 4. remote dominant speaker camera track (sorted by speaker with the loudest audio level)\n * 5. other remote speakers that are recently active\n * 6. remote unmuted camera tracks\n * 7. remote tracks sorted by joinedAt\n */\nexport function sortTrackReferences(\n  tracks: TrackReferenceOrPlaceholder[],\n): TrackReferenceOrPlaceholder[] {\n  const localTracks: TrackReferenceOrPlaceholder[] = [];\n  const screenShareTracks: TrackReferenceOrPlaceholder[] = [];\n  const cameraTracks: TrackReferenceOrPlaceholder[] = [];\n  const undefinedTracks: TrackReferenceOrPlaceholder[] = [];\n\n  tracks.forEach((trackRef) => {\n    if (trackRef.participant.isLocal && trackRef.source === Track.Source.Camera) {\n      localTracks.push(trackRef);\n    } else if (trackRef.source === Track.Source.ScreenShare) {\n      screenShareTracks.push(trackRef);\n    } else if (trackRef.source === Track.Source.Camera) {\n      cameraTracks.push(trackRef);\n    } else {\n      undefinedTracks.push(trackRef);\n    }\n  });\n\n  const sortedScreenShareTracks = sortScreenShareTracks(screenShareTracks);\n  const sortedCameraTracks = sortCameraTracks(cameraTracks);\n\n  return [...localTracks, ...sortedScreenShareTracks, ...sortedCameraTracks, ...undefinedTracks];\n}\n\n/**\n * Sort an array of `TrackReference` screen shares.\n * Main sorting order:\n * 1. remote screen shares\n * 2. local screen shares\n * Secondary sorting by participant's joining time.\n */\nfunction sortScreenShareTracks(\n  screenShareTracks: TrackReferenceOrPlaceholder[],\n): TrackReferenceOrPlaceholder[] {\n  const localScreenShares: TrackReferenceOrPlaceholder[] = [];\n  const remoteScreenShares: TrackReferenceOrPlaceholder[] = [];\n\n  screenShareTracks.forEach((trackRef) => {\n    if (trackRef.participant.isLocal) {\n      localScreenShares.push(trackRef);\n    } else {\n      remoteScreenShares.push(trackRef);\n    }\n  });\n\n  localScreenShares.sort((a, b) => sortParticipantsByJoinedAt(a.participant, b.participant));\n  remoteScreenShares.sort((a, b) => sortParticipantsByJoinedAt(a.participant, b.participant));\n\n  const sortedScreenShareTrackRefs = [...remoteScreenShares, ...localScreenShares];\n  return sortedScreenShareTrackRefs;\n}\n\nfunction sortCameraTracks(\n  cameraTrackReferences: TrackReferenceOrPlaceholder[],\n): TrackReferenceOrPlaceholder[] {\n  const localCameraTracks: TrackReferenceOrPlaceholder[] = [];\n  const remoteCameraTracks: TrackReferenceOrPlaceholder[] = [];\n\n  cameraTrackReferences.forEach((trackRef) => {\n    if (trackRef.participant.isLocal) {\n      localCameraTracks.push(trackRef);\n    } else {\n      remoteCameraTracks.push(trackRef);\n    }\n  });\n\n  remoteCameraTracks.sort((a, b) => {\n    // Participant with higher audio level goes first.\n    if (a.participant.isSpeaking && b.participant.isSpeaking) {\n      return sortParticipantsByAudioLevel(a.participant, b.participant);\n    }\n\n    // A speaking participant goes before one that is not speaking.\n    if (a.participant.isSpeaking !== b.participant.isSpeaking) {\n      return sortParticipantsByIsSpeaking(a.participant, b.participant);\n    }\n\n    // A participant that spoke recently goes before a participant that spoke a while back.\n    if (a.participant.lastSpokeAt !== b.participant.lastSpokeAt) {\n      return sortParticipantsByLastSpokenAT(a.participant, b.participant);\n    }\n\n    // TrackReference before TrackReferencePlaceholder\n    if (isTrackReference(a) !== isTrackReference(b)) {\n      return sortTrackReferencesByType(a, b);\n    }\n\n    // Tiles with video on before tiles with muted video track.\n    if (a.participant.isCameraEnabled !== b.participant.isCameraEnabled) {\n      return sortTrackRefsByIsCameraEnabled(a, b);\n    }\n\n    // A participant that joined a long time ago goes before one that joined recently.\n    return sortParticipantsByJoinedAt(a.participant, b.participant);\n  });\n\n  return [...localCameraTracks, ...remoteCameraTracks];\n}\n","import type { Participant } from 'livekit-client';\nimport { Track } from 'livekit-client';\nimport type { TrackReferenceOrPlaceholder } from '../track-reference';\nimport { getTrackReferenceSource, isTrackReference } from '../track-reference';\n\nexport function sortParticipantsByAudioLevel(\n  a: Pick<Participant, 'audioLevel'>,\n  b: Pick<Participant, 'audioLevel'>,\n): number {\n  return b.audioLevel - a.audioLevel;\n}\n\nexport function sortParticipantsByIsSpeaking(\n  a: Pick<Participant, 'isSpeaking'>,\n  b: Pick<Participant, 'isSpeaking'>,\n): number {\n  if (a.isSpeaking === b.isSpeaking) {\n    return 0;\n  } else {\n    return a.isSpeaking ? -1 : 1;\n  }\n}\n\nexport function sortParticipantsByLastSpokenAT(\n  a: Pick<Participant, 'lastSpokeAt'>,\n  b: Pick<Participant, 'lastSpokeAt'>,\n): number {\n  if (a.lastSpokeAt !== undefined || b.lastSpokeAt !== undefined) {\n    return (b.lastSpokeAt?.getTime() ?? 0) - (a.lastSpokeAt?.getTime() ?? 0);\n  } else {\n    return 0;\n  }\n}\n\nexport function sortParticipantsByJoinedAt(\n  a: Pick<Participant, 'joinedAt'>,\n  b: Pick<Participant, 'joinedAt'>,\n) {\n  return (a.joinedAt?.getTime() ?? 0) - (b.joinedAt?.getTime() ?? 0);\n}\n\nexport function sortTrackReferencesByType(\n  a: TrackReferenceOrPlaceholder,\n  b: TrackReferenceOrPlaceholder,\n) {\n  if (isTrackReference(a)) {\n    if (isTrackReference(b)) {\n      return 0;\n    } else {\n      return -1;\n    }\n  } else if (isTrackReference(b)) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\n/** TrackReference with screen share source goes first. */\nexport function sortTrackReferencesByScreenShare(\n  a: TrackReferenceOrPlaceholder,\n  b: TrackReferenceOrPlaceholder,\n): number {\n  const sourceA = getTrackReferenceSource(a);\n  const sourceB = getTrackReferenceSource(b);\n\n  if (sourceA === sourceB) {\n    if (sourceA === Track.Source.ScreenShare) {\n      if (a.participant.isLocal === b.participant.isLocal) {\n        return 0;\n      } else {\n        return a.participant.isLocal ? 1 : -1;\n      }\n    }\n    return 0;\n  } else if (sourceA === Track.Source.ScreenShare) {\n    return -1;\n  } else if (sourceB === Track.Source.ScreenShare) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nexport function sortTrackRefsByIsCameraEnabled(\n  a: { participant: { isCameraEnabled: boolean } },\n  b: { participant: { isCameraEnabled: boolean } },\n) {\n  const aVideo = a.participant.isCameraEnabled;\n  const bVideo = b.participant.isCameraEnabled;\n\n  if (aVideo !== bVideo) {\n    if (aVideo) {\n      return -1;\n    } else {\n      return 1;\n    }\n  } else {\n    return 0;\n  }\n}\n","import type { Participant } from 'livekit-client';\nimport { LocalParticipant } from 'livekit-client';\nimport {\n  sortParticipantsByAudioLevel,\n  sortParticipantsByIsSpeaking,\n  sortParticipantsByJoinedAt,\n  sortParticipantsByLastSpokenAT,\n} from './base-sort-functions';\n\n/**\n * Default sort for participants, it'll order participants by:\n * 1. local participant\n * 2. dominant speaker (speaker with the loudest audio level)\n * 3. other speakers that are recently active\n * 4. participants with video on\n * 5. by joinedAt\n */\nexport function sortParticipants(participants: Participant[]): Participant[] {\n  const sortedParticipants = [...participants];\n  sortedParticipants.sort((a, b) => {\n    // loudest speaker first\n    if (a.isSpeaking && b.isSpeaking) {\n      return sortParticipantsByAudioLevel(a, b);\n    }\n\n    // speaker goes first\n    if (a.isSpeaking !== b.isSpeaking) {\n      return sortParticipantsByIsSpeaking(a, b);\n    }\n\n    // last active speaker first\n    if (a.lastSpokeAt !== b.lastSpokeAt) {\n      return sortParticipantsByLastSpokenAT(a, b);\n    }\n\n    // video on\n    const aVideo = a.videoTrackPublications.size > 0;\n    const bVideo = b.videoTrackPublications.size > 0;\n    if (aVideo !== bVideo) {\n      if (aVideo) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n\n    // joinedAt\n    return sortParticipantsByJoinedAt(a, b);\n  });\n  const localParticipant = sortedParticipants.find((p) => p instanceof LocalParticipant);\n  if (localParticipant) {\n    const localIdx = sortedParticipants.indexOf(localParticipant);\n    if (localIdx >= 0) {\n      sortedParticipants.splice(localIdx, 1);\n      if (sortedParticipants.length > 0) {\n        sortedParticipants.splice(0, 0, localParticipant);\n      } else {\n        sortedParticipants.push(localParticipant);\n      }\n    }\n  }\n  return sortedParticipants;\n}\n","export function chunk<T>(input: Array<T>, size: number) {\n  return input.reduce(\n    (arr, item, idx) => {\n      return idx % size === 0\n        ? [...arr, [item]]\n        : [...arr.slice(0, -1), [...arr.slice(-1)[0], item]];\n    },\n    [] as Array<Array<T>>,\n  );\n}\n\nexport function zip<T, U>(a1: Array<T>, a2: Array<U>) {\n  const resultLength = Math.max(a1.length, a2.length);\n  return new Array(resultLength).fill([]).map((_val, idx) => [a1[idx], a2[idx]]);\n}\n\nexport function differenceBy<T>(a1: Array<T>, a2: Array<T>, by: (arg: T) => string) {\n  return a1.filter((c) => !a2.map((v) => by(v)).includes(by(c)));\n}\n","/**\n * Internal test function.\n *\n * @internal\n */\n\nimport { Participant, Track, TrackPublication } from 'livekit-client';\nimport type { UpdatableItem } from '../sorting/tile-array-update';\nimport type { TrackReference, TrackReferencePlaceholder } from './track-reference.types';\nimport { getTrackReferenceId } from './track-reference.utils';\n\n// Test function:\nexport const mockTrackReferencePlaceholder = (\n  id: string,\n  source: Track.Source,\n): TrackReferencePlaceholder => {\n  return { participant: new Participant(`${id}`, `${id}`), source };\n};\n\nexport const mockTrackReferencePublished = (id: string, source: Track.Source): TrackReference => {\n  const kind = [Track.Source.Camera, Track.Source.ScreenShare].includes(source)\n    ? Track.Kind.Video\n    : Track.Kind.Audio;\n  return {\n    participant: new Participant(`${id}`, `${id}`),\n    publication: new TrackPublication(kind, `${id}`, `${id}`),\n    source: source,\n  };\n};\n\ntype mockTrackReferenceSubscribedOptions = {\n  mockPublication?: boolean;\n  mockParticipant?: boolean;\n  mockIsLocal?: boolean;\n};\n\nexport const mockTrackReferenceSubscribed = (\n  id: string,\n  source: Track.Source,\n  options: mockTrackReferenceSubscribedOptions = {},\n): TrackReference => {\n  const kind = [Track.Source.Camera, Track.Source.ScreenShare].includes(source)\n    ? Track.Kind.Video\n    : Track.Kind.Audio;\n\n  const publication = new TrackPublication(kind, `${id}`, `${id}`);\n  // @ts-expect-error\n  publication.track = {};\n  return {\n    participant: options.mockParticipant\n      ? (mockParticipant(id, options.mockIsLocal ?? false) as Participant)\n      : new Participant(`${id}`, `${id}`),\n    publication: options.mockPublication\n      ? (mockTrackPublication(`publicationId(${id})`, kind, source) as TrackPublication)\n      : publication,\n    source,\n  };\n};\n\nconst mockTrackPublication = (\n  id: string,\n  kind: Track.Kind,\n  source: Track.Source,\n): Pick<TrackPublication, 'kind' | 'trackSid' | 'trackName' | 'source'> => {\n  return {\n    kind,\n    trackSid: id,\n    trackName: `name_${id}`,\n    source: source,\n  };\n};\n\nfunction mockParticipant(\n  id: string,\n  isLocal: boolean,\n): Pick<Participant, 'sid' | 'identity' | 'isLocal'> {\n  return {\n    sid: `${id}_sid`,\n    identity: `${id}`,\n    isLocal: isLocal,\n  };\n}\n\nexport function flatTrackReferenceArray<T extends UpdatableItem>(list: T[]): string[] {\n  return list.map((item) => {\n    if (typeof item === 'string' || typeof item === 'number') {\n      return `${item}`;\n    } else {\n      return getTrackReferenceId(item);\n    }\n  });\n}\n","import { differenceBy, chunk, zip } from '../helper/array-helper';\nimport { log } from '../logger';\nimport type { TrackReferenceOrPlaceholder } from '../track-reference';\nimport {\n  getTrackReferenceId,\n  isPlaceholderReplacement,\n  isTrackReference,\n  isTrackReferencePlaceholder,\n} from '../track-reference';\nimport { flatTrackReferenceArray } from '../track-reference/test-utils';\n\ntype VisualChanges<T> = {\n  dropped: T[];\n  added: T[];\n};\n\nexport type UpdatableItem = TrackReferenceOrPlaceholder | number;\n\n/** Check to see if anything visually changes on the page. */\nexport function visualPageChange<T extends UpdatableItem>(state: T[], next: T[]): VisualChanges<T> {\n  return {\n    dropped: differenceBy(state, next, getTrackReferenceId),\n    added: differenceBy(next, state, getTrackReferenceId),\n  };\n}\n\nfunction listNeedsUpdating<T>(changes: VisualChanges<T>): boolean {\n  return changes.added.length !== 0 || changes.dropped.length !== 0;\n}\n\nexport function findIndex<T extends UpdatableItem>(\n  trackReference: T,\n  trackReferences: T[],\n): number {\n  const indexToReplace = trackReferences.findIndex(\n    (trackReference_) =>\n      getTrackReferenceId(trackReference_) === getTrackReferenceId(trackReference),\n  );\n  if (indexToReplace === -1) {\n    throw new Error(\n      `Element not part of the array: ${getTrackReferenceId(\n        trackReference,\n      )} not in ${flatTrackReferenceArray(trackReferences)}`,\n    );\n  }\n  return indexToReplace;\n}\n\n/** Swap items in the complete list of all elements */\nexport function swapItems<T extends UpdatableItem>(\n  moveForward: T,\n  moveBack: T,\n  trackReferences: T[],\n): T[] {\n  const indexToReplace = findIndex(moveForward, trackReferences);\n  const indexReplaceWith = findIndex(moveBack, trackReferences);\n\n  trackReferences.splice(indexToReplace, 1, moveBack);\n  trackReferences.splice(indexReplaceWith, 1, moveForward);\n\n  return trackReferences;\n}\n\nexport function dropItem<T extends UpdatableItem>(itemToDrop: T, list: T[]): T[] {\n  const indexOfElementToDrop = findIndex(itemToDrop, list);\n  // const indexOfElementToDrop = list.findIndex((item) => item === itemToDrop, list);\n  list.splice(indexOfElementToDrop, 1);\n  return list;\n}\n\nfunction addItem<T extends UpdatableItem>(itemToAdd: T, list: T[]): T[] {\n  return [...list, itemToAdd];\n}\n\nexport function divideIntoPages<T>(list: T[], maxElementsOnPage: number): Array<T[]> {\n  const pages = chunk(list, maxElementsOnPage);\n  return pages;\n}\n\n/** Divide the list of elements into pages and and check if pages need updating. */\nexport function updatePages<T extends UpdatableItem>(\n  currentList: T[],\n  nextList: T[],\n  maxItemsOnPage: number,\n): T[] {\n  let updatedList: T[] = refreshList(currentList, nextList);\n\n  if (updatedList.length < nextList.length) {\n    // Items got added: Find newly added items and add them to the end of the list.\n    const addedItems = differenceBy(nextList, updatedList, getTrackReferenceId);\n    updatedList = [...updatedList, ...addedItems];\n  }\n  const currentPages = divideIntoPages(updatedList, maxItemsOnPage);\n  const nextPages = divideIntoPages(nextList, maxItemsOnPage);\n\n  zip(currentPages, nextPages).forEach(([currentPage, nextPage], pageIndex) => {\n    if (currentPage && nextPage) {\n      // 1) Identify  missing tile.\n      const updatedPage = divideIntoPages(updatedList, maxItemsOnPage)[pageIndex];\n      const changes = visualPageChange(updatedPage, nextPage);\n\n      if (listNeedsUpdating(changes)) {\n        log.debug(\n          `Detected visual changes on page: ${pageIndex}, current: ${flatTrackReferenceArray(\n            currentPage,\n          )}, next: ${flatTrackReferenceArray(nextPage)}`,\n          { changes },\n        );\n        // ## Swap Items\n        if (changes.added.length === changes.dropped.length) {\n          zip(changes.added, changes.dropped).forEach(([added, dropped]) => {\n            if (added && dropped) {\n              updatedList = swapItems<T>(added, dropped, updatedList);\n            } else {\n              throw new Error(\n                `For a swap action we need a addition and a removal one is missing: ${added}, ${dropped}`,\n              );\n            }\n          });\n        }\n        // ## Handle Drop Items\n        if (changes.added.length === 0 && changes.dropped.length > 0) {\n          changes.dropped.forEach((item) => {\n            updatedList = dropItem<T>(item, updatedList);\n          });\n        }\n        // ## Handle Item added\n        if (changes.added.length > 0 && changes.dropped.length === 0) {\n          changes.added.forEach((item) => {\n            updatedList = addItem<T>(item, updatedList);\n          });\n        }\n      }\n    }\n  });\n\n  if (updatedList.length > nextList.length) {\n    // Items got removed: Find items that got completely removed from the list.\n    const missingItems = differenceBy(updatedList, nextList, getTrackReferenceId);\n    updatedList = updatedList.filter(\n      (item) => !missingItems.map(getTrackReferenceId).includes(getTrackReferenceId(item)),\n    );\n  }\n\n  return updatedList;\n}\n\n/**\n * Update the current list with the items from the next list whenever the item ids are the same\n * or the current item is a placeholder and we find a track reference in the next list\n * to replace the placeholder with.\n * @remarks\n * This is needed because `TrackReference`s can change their internal state while keeping the same id.\n */\nfunction refreshList<T extends UpdatableItem>(currentList: T[], nextList: T[]): T[] {\n  return currentList.map((currentItem) => {\n    const updateForCurrentItem = nextList.find(\n      (newItem_) =>\n        // If the IDs match or ..\n        getTrackReferenceId(currentItem) === getTrackReferenceId(newItem_) ||\n        // ... if the current item is a placeholder and the new item is the track reference can replace it.\n        (typeof currentItem !== 'number' &&\n          isTrackReferencePlaceholder(currentItem) &&\n          isTrackReference(newItem_) &&\n          isPlaceholderReplacement(currentItem, newItem_)),\n    );\n    return updateForCurrentItem ?? currentItem;\n  });\n}\n","import type {\n  AudioCaptureOptions,\n  LocalParticipant,\n  Room,\n  ScreenShareCaptureOptions,\n  VideoCaptureOptions,\n} from 'livekit-client';\nimport { Track } from 'livekit-client';\nimport type { Observable } from 'rxjs';\nimport { Subject, map, startWith } from 'rxjs';\nimport { observeParticipantMedia } from '../observables/participant';\nimport { prefixClass } from '../styles-interface';\n\nexport type CaptureOptionsBySource<T extends ToggleSource> = T extends Track.Source.Camera\n  ? VideoCaptureOptions\n  : T extends Track.Source.Microphone\n    ? AudioCaptureOptions\n    : T extends Track.Source.ScreenShare\n      ? ScreenShareCaptureOptions\n      : never;\n\nexport type MediaToggleType<T extends ToggleSource> = {\n  pendingObserver: Observable<boolean>;\n  toggle: (forceState?: boolean, captureOptions?: CaptureOptionsBySource<T>) => Promise<void>;\n  className: string;\n  enabledObserver: Observable<boolean>;\n};\n\nexport type ToggleSource = Exclude<\n  Track.Source,\n  Track.Source.ScreenShareAudio | Track.Source.Unknown\n>;\n\nexport function setupMediaToggle<T extends ToggleSource>(\n  source: T,\n  room: Room,\n  options?: CaptureOptionsBySource<T>,\n): MediaToggleType<T> {\n  const { localParticipant } = room;\n\n  const getSourceEnabled = (source: ToggleSource, localParticipant: LocalParticipant) => {\n    let isEnabled = false;\n    switch (source) {\n      case Track.Source.Camera:\n        isEnabled = localParticipant.isCameraEnabled;\n        break;\n      case Track.Source.Microphone:\n        isEnabled = localParticipant.isMicrophoneEnabled;\n        break;\n      case Track.Source.ScreenShare:\n        isEnabled = localParticipant.isScreenShareEnabled;\n        break;\n      default:\n        break;\n    }\n    return isEnabled;\n  };\n\n  const enabledObserver = observeParticipantMedia(localParticipant).pipe(\n    map((media) => {\n      return getSourceEnabled(source, media.participant as LocalParticipant);\n    }),\n    startWith(getSourceEnabled(source, localParticipant)),\n  );\n\n  const pendingSubject = new Subject<boolean>();\n  const toggle = async (forceState?: boolean, captureOptions?: CaptureOptionsBySource<T>) => {\n    try {\n      captureOptions ??= options;\n      // trigger observable update\n      pendingSubject.next(true);\n      switch (source) {\n        case Track.Source.Camera:\n          await localParticipant.setCameraEnabled(\n            forceState ?? !localParticipant.isCameraEnabled,\n            captureOptions as VideoCaptureOptions,\n          );\n          break;\n        case Track.Source.Microphone:\n          await localParticipant.setMicrophoneEnabled(\n            forceState ?? !localParticipant.isMicrophoneEnabled,\n            captureOptions as AudioCaptureOptions,\n          );\n          break;\n        case Track.Source.ScreenShare:\n          await localParticipant.setScreenShareEnabled(\n            forceState ?? !localParticipant.isScreenShareEnabled,\n            captureOptions as ScreenShareCaptureOptions,\n          );\n          break;\n        default:\n          break;\n      }\n    } finally {\n      pendingSubject.next(false);\n      // trigger observable update\n    }\n  };\n\n  const className: string = prefixClass('button');\n  return {\n    className,\n    toggle,\n    enabledObserver,\n    pendingObserver: pendingSubject.asObservable(),\n  };\n}\n\nexport function setupManualToggle() {\n  let state = false;\n\n  const enabledSubject = new Subject<boolean>();\n\n  const pendingSubject = new Subject<boolean>();\n\n  const toggle = async (forceState?: boolean) => {\n    pendingSubject.next(true);\n    state = forceState ?? !state;\n    enabledSubject.next(state);\n    pendingSubject.next(false);\n  };\n  const className: string = prefixClass('button');\n  return {\n    className,\n    toggle,\n    enabledObserver: enabledSubject.asObservable(),\n    pendingObserver: pendingSubject.asObservable(),\n  };\n}\n","import type { ParticipantPermission } from '@livekit/protocol';\nimport type { Participant, RemoteParticipant, Room, TrackPublication } from 'livekit-client';\nimport { ParticipantEvent, RoomEvent, Track } from 'livekit-client';\nimport type { ParticipantEventCallbacks } from 'livekit-client/dist/src/room/participant/Participant';\nimport type { Subscriber } from 'rxjs';\nimport { Observable, map, startWith, switchMap } from 'rxjs';\nimport { getTrackByIdentifier } from '../components/mediaTrack';\nimport { allParticipantEvents, allParticipantRoomEvents } from '../helper/eventGroups';\nimport type { TrackReferenceOrPlaceholder } from '../track-reference';\nimport type { TrackIdentifier } from '../types';\nimport { observeRoomEvents } from './room';\n\nexport function observeParticipantEvents<T extends Participant>(\n  participant: T,\n  ...events: ParticipantEvent[]\n) {\n  const observable = new Observable<T>((subscribe) => {\n    const onParticipantUpdate = () => {\n      subscribe.next(participant);\n    };\n\n    events.forEach((evt) => {\n      participant.on(evt as keyof ParticipantEventCallbacks, onParticipantUpdate);\n    });\n\n    const unsubscribe = () => {\n      events.forEach((evt) => {\n        participant.off(evt as keyof ParticipantEventCallbacks, onParticipantUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith(participant));\n\n  return observable;\n}\n\nexport interface ParticipantMedia<T extends Participant = Participant> {\n  isCameraEnabled: boolean;\n  isMicrophoneEnabled: boolean;\n  isScreenShareEnabled: boolean;\n  microphoneTrack?: TrackPublication;\n  cameraTrack?: TrackPublication;\n  participant: T;\n}\n\nexport function observeParticipantMedia<T extends Participant>(participant: T) {\n  const participantObserver = observeParticipantEvents(\n    participant,\n    ParticipantEvent.TrackMuted,\n    ParticipantEvent.TrackUnmuted,\n    ParticipantEvent.ParticipantPermissionsChanged,\n    // ParticipantEvent.IsSpeakingChanged,\n    ParticipantEvent.TrackPublished,\n    ParticipantEvent.TrackUnpublished,\n    ParticipantEvent.LocalTrackPublished,\n    ParticipantEvent.LocalTrackUnpublished,\n    ParticipantEvent.MediaDevicesError,\n    ParticipantEvent.TrackSubscriptionStatusChanged,\n    // ParticipantEvent.ConnectionQualityChanged,\n  ).pipe(\n    map((p) => {\n      const { isMicrophoneEnabled, isCameraEnabled, isScreenShareEnabled } = p;\n      const microphoneTrack = p.getTrackPublication(Track.Source.Microphone);\n      const cameraTrack = p.getTrackPublication(Track.Source.Camera);\n      const participantMedia: ParticipantMedia<T> = {\n        isCameraEnabled,\n        isMicrophoneEnabled,\n        isScreenShareEnabled,\n        cameraTrack,\n        microphoneTrack,\n        participant: p,\n      };\n      return participantMedia;\n    }),\n  );\n\n  return participantObserver;\n}\n\nexport function createTrackObserver(participant: Participant, options: TrackIdentifier) {\n  return observeParticipantMedia(participant).pipe(\n    map(() => {\n      return { publication: getTrackByIdentifier(options) };\n    }),\n  );\n}\n\nexport function participantInfoObserver(participant: Participant) {\n  const observer = observeParticipantEvents(\n    participant,\n    ParticipantEvent.ParticipantMetadataChanged,\n    // ParticipantEvent.LocalTrackPublished,\n  ).pipe(\n    map(({ name, identity, metadata }) => {\n      return {\n        name,\n        identity,\n        metadata,\n      };\n    }),\n    startWith({\n      name: participant.name,\n      identity: participant.identity,\n      metadata: participant.metadata,\n    }),\n  );\n  return observer;\n}\n\nexport function createConnectionQualityObserver(participant: Participant) {\n  const observer = participantEventSelector(\n    participant,\n    ParticipantEvent.ConnectionQualityChanged,\n  ).pipe(\n    map(([quality]) => quality),\n    startWith(participant.connectionQuality),\n  );\n  return observer;\n}\n\nexport function participantEventSelector<T extends ParticipantEvent>(\n  participant: Participant,\n  event: T,\n) {\n  const observable = new Observable<\n    Parameters<ParticipantEventCallbacks[Extract<T, keyof ParticipantEventCallbacks>]>\n  >((subscribe) => {\n    const update = (\n      ...params: Parameters<ParticipantEventCallbacks[Extract<T, keyof ParticipantEventCallbacks>]>\n    ) => {\n      subscribe.next(params);\n    };\n    // @ts-expect-error not a perfect overlap between ParticipantEvent and keyof ParticipantEventCallbacks\n    participant.on(event, update);\n\n    const unsubscribe = () => {\n      // @ts-expect-error not a perfect overlap between ParticipantEvent and keyof ParticipantEventCallbacks\n      participant.off(event, update);\n    };\n    return unsubscribe;\n  });\n\n  return observable;\n}\n\nexport function mutedObserver(trackRef: TrackReferenceOrPlaceholder) {\n  return observeParticipantEvents(\n    trackRef.participant,\n    ParticipantEvent.TrackMuted,\n    ParticipantEvent.TrackUnmuted,\n    ParticipantEvent.TrackSubscribed,\n    ParticipantEvent.TrackUnsubscribed,\n    ParticipantEvent.LocalTrackPublished,\n    ParticipantEvent.LocalTrackUnpublished,\n  ).pipe(\n    map((participant) => {\n      const pub = trackRef.publication ?? participant.getTrackPublication(trackRef.source);\n      return pub?.isMuted ?? true;\n    }),\n    startWith(\n      trackRef.publication?.isMuted ??\n        trackRef.participant.getTrackPublication(trackRef.source)?.isMuted ??\n        true,\n    ),\n  );\n}\n\nexport function createIsSpeakingObserver(participant: Participant) {\n  return participantEventSelector(participant, ParticipantEvent.IsSpeakingChanged).pipe(\n    map(([isSpeaking]) => isSpeaking),\n  );\n}\n\ntype ConnectedParticipantsObserverOptions = {\n  additionalRoomEvents?: RoomEvent[];\n};\n\nexport function connectedParticipantsObserver(\n  room: Room,\n  options: ConnectedParticipantsObserverOptions = {},\n) {\n  let subscriber: Subscriber<RemoteParticipant[]> | undefined;\n\n  const observable = new Observable<RemoteParticipant[]>((sub) => {\n    subscriber = sub;\n    return () => listener.unsubscribe();\n  }).pipe(startWith(Array.from(room.remoteParticipants.values())));\n\n  const additionalRoomEvents = options.additionalRoomEvents ?? allParticipantRoomEvents;\n\n  const roomEvents = Array.from(\n    new Set([\n      RoomEvent.ParticipantConnected,\n      RoomEvent.ParticipantDisconnected,\n      RoomEvent.ConnectionStateChanged,\n      ...additionalRoomEvents,\n    ]),\n  );\n\n  const listener = observeRoomEvents(room, ...roomEvents).subscribe((r) =>\n    subscriber?.next(Array.from(r.remoteParticipants.values())),\n  );\n  if (room.remoteParticipants.size > 0) {\n    subscriber?.next(Array.from(room.remoteParticipants.values()));\n  }\n  return observable;\n}\n\nexport type ConnectedParticipantObserverOptions = {\n  additionalEvents?: ParticipantEvent[];\n};\n\nexport function connectedParticipantObserver(\n  room: Room,\n  identity: string,\n  options: ConnectedParticipantObserverOptions = {},\n) {\n  const additionalEvents = options.additionalEvents ?? allParticipantEvents;\n  const observable = observeRoomEvents(\n    room,\n    RoomEvent.ParticipantConnected,\n    RoomEvent.ParticipantDisconnected,\n    RoomEvent.ConnectionStateChanged,\n  ).pipe(\n    switchMap((r) => {\n      const participant = r.getParticipantByIdentity(identity) as RemoteParticipant | undefined;\n      if (participant) {\n        return observeParticipantEvents(participant, ...additionalEvents);\n      } else {\n        return new Observable<undefined>((subscribe) => subscribe.next(undefined));\n      }\n    }),\n    startWith(room.getParticipantByIdentity(identity) as RemoteParticipant | undefined),\n  );\n\n  return observable;\n}\n\nexport function participantPermissionObserver(\n  participant: Participant,\n): Observable<ParticipantPermission | undefined> {\n  const observer = participantEventSelector(\n    participant,\n    ParticipantEvent.ParticipantPermissionsChanged,\n  ).pipe(\n    map(() => participant.permissions),\n    startWith(participant.permissions),\n  );\n  return observer;\n}\n","import { Track } from 'livekit-client';\nimport { map, startWith } from 'rxjs';\nimport { observeParticipantMedia } from '../observables/participant';\nimport { prefixClass } from '../styles-interface';\nimport { isTrackReference } from '../track-reference/track-reference.types';\nimport type { TrackIdentifier } from '../types';\n\nexport function setupMediaTrack(trackIdentifier: TrackIdentifier) {\n  const initialPub = getTrackByIdentifier(trackIdentifier);\n  const trackObserver = observeParticipantMedia(trackIdentifier.participant).pipe(\n    map(() => {\n      return getTrackByIdentifier(trackIdentifier);\n    }),\n    startWith(initialPub),\n  );\n  const className: string = prefixClass(\n    trackIdentifier.source === Track.Source.Camera ||\n      trackIdentifier.source === Track.Source.ScreenShare\n      ? 'participant-media-video'\n      : 'participant-media-audio',\n  );\n  return { className, trackObserver };\n}\n\nexport function getTrackByIdentifier(options: TrackIdentifier) {\n  if (isTrackReference(options)) {\n    return options.publication;\n  } else {\n    const { source, name, participant } = options;\n    if (source && name) {\n      return participant\n        .getTrackPublications()\n        .find((pub) => pub.source === source && pub.trackName === name);\n    } else if (name) {\n      return participant.getTrackPublicationByName(name);\n    } else if (source) {\n      return participant.getTrackPublication(source);\n    } else {\n      throw new Error('At least one of source and name needs to be defined');\n    }\n  }\n}\n","import type { UnprefixedClassNames as ComponentNoPrefixClasses } from '@livekit/components-styles/dist/types_unprefixed/index.scss';\nimport type { UnprefixedClassNames as PrefabNoPrefixClasses } from '@livekit/components-styles/dist/types_unprefixed/prefabs/index.scss';\nimport { cssPrefix } from './../constants';\n\ntype UnprefixedClassNames = ComponentNoPrefixClasses | PrefabNoPrefixClasses;\n\n/**\n * This function is a type safe way to add a prefix to a HTML class attribute.\n * Only classes defined in the styles module are valid, any other class produces a ts error.\n * @internal\n */\nexport function prefixClass<T extends UnprefixedClassNames>(unprefixedClassName: T) {\n  return `${cssPrefix}-${unprefixedClassName}` as const;\n}\n","import type { Subscriber, Subscription } from 'rxjs';\nimport { Subject, map, Observable, startWith, finalize, filter, concat } from 'rxjs';\nimport type { Participant, TrackPublication } from 'livekit-client';\nimport { LocalParticipant, Room, RoomEvent, Track } from 'livekit-client';\nimport type { RoomEventCallbacks } from 'livekit-client/dist/src/room/Room';\nimport { log } from '../logger';\nexport function observeRoomEvents(room: Room, ...events: RoomEvent[]): Observable<Room> {\n  const observable = new Observable<Room>((subscribe) => {\n    const onRoomUpdate = () => {\n      subscribe.next(room);\n    };\n\n    events.forEach((evt) => {\n      room.on(evt, onRoomUpdate);\n    });\n\n    const unsubscribe = () => {\n      events.forEach((evt) => {\n        room.off(evt, onRoomUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith(room));\n\n  return observable;\n}\n\nexport function roomEventSelector<T extends RoomEvent>(room: Room, event: T) {\n  const observable = new Observable<Parameters<RoomEventCallbacks[T]>>((subscribe) => {\n    const update = (...params: Parameters<RoomEventCallbacks[T]>) => {\n      subscribe.next(params);\n    };\n    room.on(event as keyof RoomEventCallbacks, update);\n\n    const unsubscribe = () => {\n      room.off(event as keyof RoomEventCallbacks, update);\n    };\n    return unsubscribe;\n  });\n\n  return observable;\n}\n\nexport function roomObserver(room: Room) {\n  const observable = observeRoomEvents(\n    room,\n    RoomEvent.ParticipantConnected,\n    RoomEvent.ParticipantDisconnected,\n    RoomEvent.ActiveSpeakersChanged,\n    RoomEvent.TrackSubscribed,\n    RoomEvent.TrackUnsubscribed,\n    RoomEvent.LocalTrackPublished,\n    RoomEvent.LocalTrackUnpublished,\n    RoomEvent.AudioPlaybackStatusChanged,\n    RoomEvent.ConnectionStateChanged,\n  ).pipe(startWith(room));\n\n  return observable;\n}\n\nexport function connectionStateObserver(room: Room) {\n  return roomEventSelector(room, RoomEvent.ConnectionStateChanged).pipe(\n    map(([connectionState]) => connectionState),\n    startWith(room.state),\n  );\n}\nexport type ScreenShareTrackMap = Array<{\n  participant: Participant;\n  tracks: Array<TrackPublication>;\n}>;\n\nexport function screenShareObserver(room: Room) {\n  let screenShareSubscriber: Subscriber<ScreenShareTrackMap>;\n  const observers: Array<Subscription> = [];\n\n  const observable = new Observable<ScreenShareTrackMap>((subscriber) => {\n    screenShareSubscriber = subscriber;\n    return () => {\n      observers.forEach((observer) => {\n        observer.unsubscribe();\n      });\n    };\n  });\n  const screenShareTracks: ScreenShareTrackMap = [];\n\n  const handleSub = (publication: TrackPublication, participant: Participant) => {\n    if (\n      publication.source !== Track.Source.ScreenShare &&\n      publication.source !== Track.Source.ScreenShareAudio\n    ) {\n      return;\n    }\n    let trackMap = screenShareTracks.find((tr) => tr.participant.identity === participant.identity);\n    const getScreenShareTracks = (participant: Participant) => {\n      return participant\n        .getTrackPublications()\n        .filter(\n          (track) =>\n            (track.source === Track.Source.ScreenShare ||\n              track.source === Track.Source.ScreenShareAudio) &&\n            track.track,\n        );\n    };\n    if (!trackMap) {\n      trackMap = {\n        participant,\n        tracks: getScreenShareTracks(participant),\n      };\n    } else {\n      const index = screenShareTracks.indexOf(trackMap);\n      screenShareTracks.splice(index, 1);\n      trackMap.tracks = getScreenShareTracks(participant);\n    }\n    if (trackMap.tracks.length > 0) {\n      screenShareTracks.push(trackMap);\n    }\n\n    screenShareSubscriber.next(screenShareTracks);\n  };\n  observers.push(\n    roomEventSelector(room, RoomEvent.TrackSubscribed).subscribe(([, ...args]) =>\n      handleSub(...args),\n    ),\n  );\n  observers.push(\n    roomEventSelector(room, RoomEvent.TrackUnsubscribed).subscribe(([, ...args]) =>\n      handleSub(...args),\n    ),\n  );\n  observers.push(\n    roomEventSelector(room, RoomEvent.LocalTrackPublished).subscribe((args) => handleSub(...args)),\n  );\n  observers.push(\n    roomEventSelector(room, RoomEvent.LocalTrackUnpublished).subscribe((args) => {\n      handleSub(...args);\n    }),\n  );\n  observers.push(\n    roomEventSelector(room, RoomEvent.TrackMuted).subscribe((args) => {\n      handleSub(...args);\n    }),\n  );\n  observers.push(\n    roomEventSelector(room, RoomEvent.TrackUnmuted).subscribe((args) => {\n      handleSub(...args);\n    }),\n  );\n  setTimeout(() => {\n    // TODO find way to avoid this timeout\n    for (const p of room.remoteParticipants.values()) {\n      p.getTrackPublications().forEach((track) => {\n        handleSub(track, p);\n      });\n    }\n  }, 1);\n\n  return observable;\n}\n\nexport function roomInfoObserver(room: Room) {\n  const observer = observeRoomEvents(\n    room,\n    RoomEvent.RoomMetadataChanged,\n    RoomEvent.ConnectionStateChanged,\n  ).pipe(\n    map((r) => {\n      return { name: r.name, metadata: r.metadata };\n    }),\n  );\n  return observer;\n}\n\nexport function activeSpeakerObserver(room: Room) {\n  return roomEventSelector(room, RoomEvent.ActiveSpeakersChanged).pipe(\n    map(([speakers]) => speakers),\n  );\n}\n\nexport function createMediaDeviceObserver(\n  kind?: MediaDeviceKind,\n  onError?: (e: Error) => void,\n  requestPermissions = true,\n) {\n  const onDeviceChange = async () => {\n    try {\n      const newDevices = await Room.getLocalDevices(kind, requestPermissions);\n      deviceSubject.next(newDevices);\n    } catch (e: any) {\n      onError?.(e);\n    }\n  };\n  const deviceSubject = new Subject<MediaDeviceInfo[]>();\n\n  const observable = deviceSubject.pipe(\n    finalize(() => {\n      navigator?.mediaDevices?.removeEventListener('devicechange', onDeviceChange);\n    }),\n  );\n\n  if (typeof window !== 'undefined') {\n    if (!window.isSecureContext) {\n      throw new Error(\n        `Accessing media devices is available only in secure contexts (HTTPS and localhost), in some or all supporting browsers. See: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/mediaDevices`,\n      );\n    }\n    navigator?.mediaDevices?.addEventListener('devicechange', onDeviceChange);\n  }\n  // because we rely on an async function, concat the promise to retrieve the initial values with the observable\n  return concat(\n    Room.getLocalDevices(kind, requestPermissions).catch((e) => {\n      onError?.(e);\n      return [] as MediaDeviceInfo[];\n    }),\n    observable,\n  );\n}\n\nexport function createDataObserver(room: Room) {\n  return roomEventSelector(room, RoomEvent.DataReceived);\n}\n\nexport function roomAudioPlaybackAllowedObservable(room: Room) {\n  const observable = observeRoomEvents(room, RoomEvent.AudioPlaybackStatusChanged).pipe(\n    map((room) => {\n      return { canPlayAudio: room.canPlaybackAudio };\n    }),\n  );\n  return observable;\n}\n\nexport function roomVideoPlaybackAllowedObservable(room: Room) {\n  const observable = observeRoomEvents(room, RoomEvent.VideoPlaybackStatusChanged).pipe(\n    map((room) => {\n      return { canPlayVideo: room.canPlaybackVideo };\n    }),\n  );\n  return observable;\n}\n\nexport function createActiveDeviceObservable(room: Room, kind: MediaDeviceKind) {\n  return roomEventSelector(room, RoomEvent.ActiveDeviceChanged).pipe(\n    filter(([kindOfDevice]) => kindOfDevice === kind),\n    map(([kind, deviceId]) => {\n      log.debug('activeDeviceObservable | RoomEvent.ActiveDeviceChanged', { kind, deviceId });\n      return deviceId;\n    }),\n    startWith(room.getActiveDevice(kind)),\n  );\n}\n\nexport function encryptionStatusObservable(room: Room, participant: Participant) {\n  return roomEventSelector(room, RoomEvent.ParticipantEncryptionStatusChanged).pipe(\n    filter(\n      ([, p]) =>\n        participant.identity === p?.identity ||\n        (!p && participant.identity === room.localParticipant.identity),\n    ),\n    map(([encrypted]) => encrypted),\n    startWith(\n      participant instanceof LocalParticipant ? participant.isE2EEEnabled : participant.isEncrypted,\n    ),\n  );\n}\n","import {\n  Track,\n  type LocalAudioTrack,\n  type LocalVideoTrack,\n  type Room,\n  type LocalTrack,\n} from 'livekit-client';\nimport { BehaviorSubject } from 'rxjs';\nimport { log } from '../logger';\nimport { prefixClass } from '../styles-interface';\nimport { createActiveDeviceObservable } from '../observables/room';\n\nexport type SetMediaDeviceOptions = {\n  /**\n   *  If true, adds an `exact` constraint to the getUserMedia request.\n   *  The request will fail if this option is true and the device specified is not actually available\n   */\n  exact?: boolean;\n};\n\nexport function setupDeviceSelector(\n  kind: MediaDeviceKind,\n  room?: Room,\n  localTrack?: LocalAudioTrack | LocalVideoTrack,\n) {\n  const activeDeviceSubject = new BehaviorSubject<string | undefined>(undefined);\n\n  const activeDeviceObservable = room\n    ? createActiveDeviceObservable(room, kind)\n    : activeDeviceSubject.asObservable();\n\n  const setActiveMediaDevice = async (id: string, options: SetMediaDeviceOptions = {}) => {\n    if (room) {\n      log.debug(`Switching active device of kind \"${kind}\" with id ${id}.`);\n      await room.switchActiveDevice(kind, id, options.exact);\n      const actualDeviceId: string | undefined = room.getActiveDevice(kind) ?? id;\n      if (actualDeviceId !== id && id !== 'default') {\n        log.info(\n          `We tried to select the device with id (${id}), but the browser decided to select the device with id (${actualDeviceId}) instead.`,\n        );\n      }\n      let targetTrack: LocalTrack | undefined = undefined;\n      if (kind === 'audioinput')\n        targetTrack = room.localParticipant.getTrackPublication(Track.Source.Microphone)?.track;\n      else if (kind === 'videoinput') {\n        targetTrack = room.localParticipant.getTrackPublication(Track.Source.Camera)?.track;\n      }\n      const useDefault =\n        (id === 'default' && !targetTrack) ||\n        (id === 'default' && targetTrack?.mediaStreamTrack.label.startsWith('Default'));\n      activeDeviceSubject.next(useDefault ? id : actualDeviceId);\n    } else if (localTrack) {\n      await localTrack.setDeviceId(options.exact ? { exact: id } : id);\n      const actualId = await localTrack.getDeviceId();\n      activeDeviceSubject.next(\n        id === 'default' && localTrack.mediaStreamTrack.label.startsWith('Default') ? id : actualId,\n      );\n    } else if (activeDeviceSubject.value !== id) {\n      log.warn(\n        'device switch skipped, please provide either a room or a local track to switch on. ',\n      );\n      activeDeviceSubject.next(id);\n    }\n  };\n  const className: string = prefixClass('media-device-select');\n  return {\n    className,\n    activeDeviceObservable,\n    setActiveMediaDevice,\n  };\n}\n","import type { Room } from 'livekit-client';\nimport { prefixClass } from '../styles-interface';\n\nexport function setupDisconnectButton(room: Room) {\n  const disconnect = (stopTracks?: boolean) => {\n    room.disconnect(stopTracks);\n  };\n  const className: string = prefixClass('disconnect-button');\n  return { className, disconnect };\n}\n","import type { Participant } from 'livekit-client';\nimport { createConnectionQualityObserver } from '../observables/participant';\nimport { prefixClass } from '../styles-interface';\n\nexport function setupConnectionQualityIndicator(participant: Participant) {\n  const className = prefixClass('connection-quality');\n  const connectionQualityObserver = createConnectionQualityObserver(participant);\n  return { className, connectionQualityObserver };\n}\n","import type { Styles } from '@livekit/components-styles/dist/types_unprefixed/index.scss';\nimport { Track } from 'livekit-client';\nimport { mutedObserver } from '../observables/participant';\nimport { prefixClass } from '../styles-interface';\nimport type { TrackReferenceOrPlaceholder } from '../track-reference';\n\nexport function setupTrackMutedIndicator(trackRef: TrackReferenceOrPlaceholder) {\n  let classForSource: keyof Styles = 'track-muted-indicator-camera';\n  switch (trackRef.source) {\n    case Track.Source.Camera:\n      classForSource = 'track-muted-indicator-camera';\n      break;\n    case Track.Source.Microphone:\n      classForSource = 'track-muted-indicator-microphone';\n      break;\n\n    default:\n      break;\n  }\n  const className: string = prefixClass(classForSource);\n  const mediaMutedObserver = mutedObserver(trackRef);\n\n  return { className, mediaMutedObserver };\n}\n","import type { Participant } from 'livekit-client';\nimport { participantInfoObserver } from '../observables/participant';\n\nexport function setupParticipantName(participant: Participant) {\n  const infoObserver = participantInfoObserver(participant);\n  return { className: 'lk-participant-name', infoObserver };\n}\n","import { prefixClass } from '../styles-interface';\n\nexport function setupParticipantTile() {\n  const className: string = prefixClass('participant-tile');\n  return {\n    className,\n  };\n}\n","/* eslint-disable camelcase */\nimport type { Participant, Room } from 'livekit-client';\nimport { RoomEvent } from 'livekit-client';\nimport { BehaviorSubject, Subject, scan, map, takeUntil } from 'rxjs';\nimport { DataTopic, sendMessage, setupDataMessageHandler } from '../observables/dataChannel';\n\n/** @public */\nexport interface ChatMessage {\n  id: string;\n  timestamp: number;\n  message: string;\n}\n\n/** @public */\nexport interface ReceivedChatMessage extends ChatMessage {\n  from?: Participant;\n  editTimestamp?: number;\n}\n\n/** @public */\nexport type MessageEncoder = (message: ChatMessage) => Uint8Array;\n/** @public */\nexport type MessageDecoder = (message: Uint8Array) => ReceivedChatMessage;\n/** @public */\nexport type ChatOptions = {\n  messageEncoder?: (message: ChatMessage) => Uint8Array;\n  messageDecoder?: (message: Uint8Array) => ReceivedChatMessage;\n  channelTopic?: string;\n  updateChannelTopic?: string;\n};\n\ntype RawMessage = {\n  payload: Uint8Array;\n  topic: string | undefined;\n  from: Participant | undefined;\n};\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n\nconst topicSubjectMap: Map<Room, Map<string, Subject<RawMessage>>> = new Map();\n\nconst encode = (message: ChatMessage) => encoder.encode(JSON.stringify(message));\n\nconst decode = (message: Uint8Array) => JSON.parse(decoder.decode(message)) as ReceivedChatMessage;\n\nexport function setupChat(room: Room, options?: ChatOptions) {\n  const onDestroyObservable = new Subject<void>();\n\n  const { messageDecoder, messageEncoder, channelTopic, updateChannelTopic } = options ?? {};\n\n  const topic = channelTopic ?? DataTopic.CHAT;\n\n  const updateTopic = updateChannelTopic ?? DataTopic.CHAT_UPDATE;\n\n  let needsSetup = false;\n  if (!topicSubjectMap.has(room)) {\n    needsSetup = true;\n  }\n  const topicMap = topicSubjectMap.get(room) ?? new Map<string, Subject<RawMessage>>();\n  const messageSubject = topicMap.get(topic) ?? new Subject<RawMessage>();\n  topicMap.set(topic, messageSubject);\n  topicSubjectMap.set(room, topicMap);\n\n  if (needsSetup) {\n    /** Subscribe to all appropriate messages sent over the wire. */\n    const { messageObservable } = setupDataMessageHandler(room, [topic, updateTopic]);\n    messageObservable.pipe(takeUntil(onDestroyObservable)).subscribe(messageSubject);\n  }\n\n  const finalMessageDecoder = messageDecoder ?? decode;\n\n  /** Build up the message array over time. */\n  const messagesObservable = messageSubject.pipe(\n    map((msg) => {\n      const parsedMessage = finalMessageDecoder(msg.payload);\n      const newMessage: ReceivedChatMessage = { ...parsedMessage, from: msg.from };\n      return newMessage;\n    }),\n    scan<ReceivedChatMessage, ReceivedChatMessage[]>((acc, value) => {\n      // handle message updates\n      if (\n        'id' in value &&\n        acc.find((msg) => msg.from?.identity === value.from?.identity && msg.id === value.id)\n      ) {\n        const replaceIndex = acc.findIndex((msg) => msg.id === value.id);\n        if (replaceIndex > -1) {\n          const originalMsg = acc[replaceIndex];\n          acc[replaceIndex] = {\n            ...value,\n            timestamp: originalMsg.timestamp,\n            editTimestamp: value.timestamp,\n          };\n        }\n\n        return [...acc];\n      }\n      return [...acc, value];\n    }, []),\n    takeUntil(onDestroyObservable),\n  );\n\n  const isSending$ = new BehaviorSubject<boolean>(false);\n\n  const finalMessageEncoder = messageEncoder ?? encode;\n\n  const send = async (message: string) => {\n    const timestamp = Date.now();\n    const id = crypto.randomUUID();\n    const chatMessage: ChatMessage = { id, message, timestamp };\n    const encodedMsg = finalMessageEncoder(chatMessage);\n    isSending$.next(true);\n    try {\n      await sendMessage(room.localParticipant, encodedMsg, {\n        reliable: true,\n        topic,\n      });\n      messageSubject.next({\n        payload: encodedMsg,\n        topic: topic,\n        from: room.localParticipant,\n      });\n      return chatMessage;\n    } finally {\n      isSending$.next(false);\n    }\n  };\n\n  const update = async (message: string, messageId: string) => {\n    const timestamp = Date.now();\n    const chatMessage: ChatMessage = { id: messageId, message, timestamp };\n    const encodedMsg = finalMessageEncoder(chatMessage);\n    isSending$.next(true);\n    try {\n      await sendMessage(room.localParticipant, encodedMsg, {\n        topic: updateTopic,\n        reliable: true,\n      });\n      messageSubject.next({\n        payload: encodedMsg,\n        topic: topic,\n        from: room.localParticipant,\n      });\n      return chatMessage;\n    } finally {\n      isSending$.next(false);\n    }\n  };\n\n  function destroy() {\n    onDestroyObservable.next();\n    onDestroyObservable.complete();\n    topicSubjectMap.clear();\n  }\n  room.once(RoomEvent.Disconnected, destroy);\n\n  return { messageObservable: messagesObservable, isSendingObservable: isSending$, send, update };\n}\n","import type { DataPublishOptions, LocalParticipant, Participant, Room } from 'livekit-client';\nimport type { Subscriber } from 'rxjs';\nimport { Observable, filter, map } from 'rxjs';\nimport { createDataObserver } from './room';\n\nexport const DataTopic = {\n  CHAT: 'lk-chat-topic',\n  CHAT_UPDATE: 'lk-chat-update-topic',\n} as const;\n\n/** Publish data from the LocalParticipant. */\nexport async function sendMessage(\n  localParticipant: LocalParticipant,\n  payload: Uint8Array,\n  options: DataPublishOptions = {},\n) {\n  const { reliable, destinationIdentities, topic } = options;\n\n  await localParticipant.publishData(payload, {\n    destinationIdentities,\n    topic,\n    reliable,\n  });\n}\n\nexport interface BaseDataMessage<T extends string | undefined> {\n  topic?: T;\n  payload: Uint8Array;\n}\n\nexport interface ReceivedDataMessage<T extends string | undefined = string>\n  extends BaseDataMessage<T> {\n  from?: Participant;\n}\n\nexport function setupDataMessageHandler<T extends string>(\n  room: Room,\n  topic?: T | [T, ...T[]],\n  onMessage?: (msg: ReceivedDataMessage<T>) => void,\n) {\n  const topics = Array.isArray(topic) ? topic : [topic];\n  /** Setup a Observable that returns all data messages belonging to a topic. */\n  const messageObservable = createDataObserver(room).pipe(\n    filter(\n      ([, , , messageTopic]) =>\n        topic === undefined || (messageTopic !== undefined && topics.includes(messageTopic as T)),\n    ),\n    map(([payload, participant, , messageTopic]) => {\n      const msg = {\n        payload,\n        topic: messageTopic as T,\n        from: participant,\n      } satisfies ReceivedDataMessage<T>;\n      onMessage?.(msg);\n      return msg;\n    }),\n  );\n\n  let isSendingSubscriber: Subscriber<boolean>;\n  const isSendingObservable = new Observable<boolean>((subscriber) => {\n    isSendingSubscriber = subscriber;\n  });\n\n  const send = async (payload: Uint8Array, options: DataPublishOptions = {}) => {\n    isSendingSubscriber.next(true);\n    try {\n      await sendMessage(room.localParticipant, payload, { topic: topics[0], ...options });\n    } finally {\n      isSendingSubscriber.next(false);\n    }\n  };\n\n  return { messageObservable, isSendingObservable, send };\n}\n","import type { Room } from 'livekit-client';\nimport { log } from '../logger';\nimport { roomAudioPlaybackAllowedObservable } from '../observables/room';\nimport { prefixClass } from '../styles-interface';\n\nexport function setupStartAudio() {\n  const handleStartAudioPlayback = async (room: Room) => {\n    log.info('Start Audio for room: ', room);\n    await room.startAudio();\n  };\n  const className: string = prefixClass('start-audio-button');\n  return { className, roomAudioPlaybackAllowedObservable, handleStartAudioPlayback };\n}\n","import type { Room } from 'livekit-client';\nimport { log } from '../logger';\nimport { roomVideoPlaybackAllowedObservable } from '../observables/room';\nimport { prefixClass } from '../styles-interface';\n\nexport function setupStartVideo() {\n  const handleStartVideoPlayback = async (room: Room) => {\n    log.info('Start Video for room: ', room);\n    await room.startVideo();\n  };\n  const className: string = prefixClass('start-audio-button');\n  return { className, roomVideoPlaybackAllowedObservable, handleStartVideoPlayback };\n}\n","import { prefixClass } from '../styles-interface';\n\nexport function setupChatToggle() {\n  const className: string = [prefixClass('button'), prefixClass('chat-toggle')].join(' ');\n  return { className };\n}\n","import { prefixClass } from '../styles-interface';\n\nexport function setupFocusToggle() {\n  const className: string = [prefixClass('button'), prefixClass('focus-toggle-button')].join(' ');\n  return { className };\n}\n","// import { prefixClass } from '../styles-interface';\n\nexport function setupClearPinButton() {\n  // const className = prefixClass('clear-pin-button');\n  const className = 'lk-clear-pin-button lk-button';\n  return { className };\n}\n","export function setupLiveKitRoom() {\n  const className = 'lk-room-container';\n  return { className };\n}\n","import type {\n  LocalTrackPublication,\n  Participant,\n  RemoteTrackPublication,\n  Room,\n  Track,\n  TrackPublication,\n} from 'livekit-client';\nimport { RoomEvent, TrackEvent } from 'livekit-client';\nimport { map, Observable, startWith } from 'rxjs';\nimport { allParticipantRoomEvents, participantTrackEvents } from '../helper';\nimport { log } from '../logger';\nimport type { TrackReference } from '../track-reference';\nimport { observeRoomEvents } from './room';\nimport type { ParticipantTrackIdentifier } from '../types';\nimport { observeParticipantEvents } from './participant';\n\nexport function trackObservable(track: TrackPublication) {\n  const trackObserver = observeTrackEvents(\n    track,\n    TrackEvent.Muted,\n    TrackEvent.Unmuted,\n    TrackEvent.Subscribed,\n    TrackEvent.Unsubscribed,\n  );\n\n  return trackObserver;\n}\n\nexport function observeTrackEvents(track: TrackPublication, ...events: TrackEvent[]) {\n  const observable = new Observable<TrackPublication>((subscribe) => {\n    const onTrackUpdate = () => {\n      subscribe.next(track);\n    };\n\n    events.forEach((evt) => {\n      // @ts-expect-error type of `TrackEvent` and `PublicationCallbacks` are congruent\n      track.on(evt, onTrackUpdate);\n    });\n\n    const unsubscribe = () => {\n      events.forEach((evt) => {\n        // @ts-expect-error type of `TrackEvent` and `PublicationCallbacks` are congruent\n        track.off(evt, onTrackUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith(track));\n\n  return observable;\n}\n\n/**\n * Create `TrackReferences` for all tracks that are included in the sources property.\n *  */\nfunction getTrackReferences(\n  room: Room,\n  sources: Track.Source[],\n  onlySubscribedTracks = true,\n): { trackReferences: TrackReference[]; participants: Participant[] } {\n  const localParticipant = room.localParticipant;\n  const allParticipants = [localParticipant, ...Array.from(room.remoteParticipants.values())];\n  const trackReferences: TrackReference[] = [];\n\n  allParticipants.forEach((participant) => {\n    sources.forEach((source) => {\n      const sourceReferences = Array.from<RemoteTrackPublication | LocalTrackPublication>(\n        participant.trackPublications.values(),\n      )\n        .filter(\n          (track) =>\n            track.source === source &&\n            // either return all or only the ones that are subscribed\n            (!onlySubscribedTracks || track.track),\n        )\n        .map((track): TrackReference => {\n          return {\n            participant: participant,\n            publication: track,\n            source: track.source,\n          };\n        });\n\n      trackReferences.push(...sourceReferences);\n    });\n  });\n\n  return { trackReferences, participants: allParticipants };\n}\n\n/**\n * Create `TrackReferences` for all tracks that are included in the sources property.\n *  */\nfunction getParticipantTrackRefs(\n  participant: Participant,\n  identifier: ParticipantTrackIdentifier,\n  onlySubscribedTracks = false,\n): TrackReference[] {\n  const { sources, kind, name } = identifier;\n  const sourceReferences = Array.from(participant.trackPublications.values())\n    .filter(\n      (pub) =>\n        (!sources || sources.includes(pub.source)) &&\n        (!kind || pub.kind === kind) &&\n        (!name || pub.trackName === name) &&\n        // either return all or only the ones that are subscribed\n        (!onlySubscribedTracks || pub.track),\n    )\n    .map((track): TrackReference => {\n      return {\n        participant: participant,\n        publication: track,\n        source: track.source,\n      };\n    });\n\n  return sourceReferences;\n}\n\ntype TrackReferencesObservableOptions = {\n  additionalRoomEvents?: RoomEvent[];\n  onlySubscribed?: boolean;\n};\n\nexport function trackReferencesObservable(\n  room: Room,\n  sources: Track.Source[],\n  options: TrackReferencesObservableOptions,\n): Observable<{ trackReferences: TrackReference[]; participants: Participant[] }> {\n  const additionalRoomEvents = options.additionalRoomEvents ?? allParticipantRoomEvents;\n  const onlySubscribedTracks: boolean = options.onlySubscribed ?? true;\n  const roomEvents = Array.from(\n    new Set([\n      RoomEvent.ParticipantConnected,\n      RoomEvent.ParticipantDisconnected,\n      RoomEvent.ConnectionStateChanged,\n      RoomEvent.LocalTrackPublished,\n      RoomEvent.LocalTrackUnpublished,\n      RoomEvent.TrackPublished,\n      RoomEvent.TrackUnpublished,\n      RoomEvent.TrackSubscriptionStatusChanged,\n      ...additionalRoomEvents,\n    ]).values(),\n  );\n\n  const observable = observeRoomEvents(room, ...roomEvents).pipe(\n    map((room) => {\n      const data = getTrackReferences(room, sources, onlySubscribedTracks);\n      log.debug(`TrackReference[] was updated. (length ${data.trackReferences.length})`, data);\n      return data;\n    }),\n    startWith(getTrackReferences(room, sources, onlySubscribedTracks)),\n  );\n\n  return observable;\n}\n\nexport function participantTracksObservable(\n  participant: Participant,\n  trackIdentifier: ParticipantTrackIdentifier,\n): Observable<TrackReference[]> {\n  const observable = observeParticipantEvents(participant, ...participantTrackEvents).pipe(\n    map((participant) => {\n      const data = getParticipantTrackRefs(participant, trackIdentifier);\n      log.debug(`TrackReference[] was updated. (length ${data.length})`, data);\n      return data;\n    }),\n    startWith(getParticipantTrackRefs(participant, trackIdentifier)),\n  );\n\n  return observable;\n}\n","import type { Observable } from 'rxjs';\nimport { concat, distinctUntilChanged, fromEvent, map, of, skipUntil, timeout } from 'rxjs';\n\n/**\n * Returns true if the user is interacting with the HTML element,\n * and returns false if there is no interaction for a specified period of time.\n *\n * @internal\n */\nexport function createInteractingObservable(htmlElement: HTMLElement | null, inactiveAfter = 1000) {\n  if (htmlElement === null) return of(false);\n  const move$ = fromEvent(htmlElement, 'mousemove', { passive: true }).pipe(map(() => true));\n  const moveAndStop$: Observable<boolean> = move$.pipe(\n    timeout({\n      each: inactiveAfter,\n      with: () => concat(of(false), moveAndStop$.pipe(skipUntil(move$))),\n    }),\n    distinctUntilChanged(),\n  );\n  return moveAndStop$;\n}\n","import { log } from '../logger';\n\ntype JsonPrimitive = string | number | boolean | null;\ntype JsonArray = JsonValue[];\ntype JsonObject = { [key: string]: JsonValue };\ntype JsonValue = JsonPrimitive | JsonArray | JsonObject;\n\n/**\n * Persists a serializable object to local storage associated with the specified key.\n * @internal\n */\nfunction saveToLocalStorage<T extends JsonValue>(key: string, value: T): void {\n  if (typeof localStorage === 'undefined') {\n    log.error('Local storage is not available.');\n    return;\n  }\n\n  try {\n    localStorage.setItem(key, JSON.stringify(value));\n  } catch (error) {\n    log.error(`Error setting item to local storage: ${error}`);\n  }\n}\n\n/**\n * Retrieves a serializable object from local storage by its key.\n * @internal\n */\nfunction loadFromLocalStorage<T extends JsonValue>(key: string): T | undefined {\n  if (typeof localStorage === 'undefined') {\n    log.error('Local storage is not available.');\n    return undefined;\n  }\n\n  try {\n    const item = localStorage.getItem(key);\n    if (!item) {\n      log.warn(`Item with key ${key} does not exist in local storage.`);\n      return undefined;\n    }\n    return JSON.parse(item);\n  } catch (error) {\n    log.error(`Error getting item from local storage: ${error}`);\n    return undefined;\n  }\n}\n\n/**\n * Generate a pair of functions to load and save a value of type T to local storage.\n * @internal\n */\nexport function createLocalStorageInterface<T extends JsonValue>(\n  key: string,\n): { load: () => T | undefined; save: (value: T) => void } {\n  return {\n    load: () => loadFromLocalStorage<T>(key),\n    save: (value: T) => saveToLocalStorage<T>(key, value),\n  };\n}\n","import { cssPrefix } from '../constants';\nimport { createLocalStorageInterface } from './local-storage-helpers';\n\nconst USER_CHOICES_KEY = `${cssPrefix}-user-choices` as const;\n\n/**\n * @public\n * Represents the user's choices for video and audio input devices,\n * as well as their username.\n */\nexport type LocalUserChoices = {\n  /**\n   * Whether video input is enabled.\n   * @defaultValue `true`\n   */\n  videoEnabled: boolean;\n  /**\n   * Whether audio input is enabled.\n   * @defaultValue `true`\n   */\n  audioEnabled: boolean;\n  /**\n   * The device ID of the video input device to use.\n   * @defaultValue `''`\n   */\n  videoDeviceId: string;\n  /**\n   * The device ID of the audio input device to use.\n   * @defaultValue `''`\n   */\n  audioDeviceId: string;\n  /**\n   * The username to use.\n   * @defaultValue `''`\n   */\n  username: string;\n};\n\nexport const defaultUserChoices: LocalUserChoices = {\n  videoEnabled: true,\n  audioEnabled: true,\n  videoDeviceId: '',\n  audioDeviceId: '',\n  username: '',\n} as const;\n\n/**\n * The type of the object stored in local storage.\n * @remarks\n * TODO: Replace this type with `LocalUserChoices` after removing the deprecated properties from `LocalUserChoices`.\n * @internal\n */\ntype TempStorageType = Omit<LocalUserChoices, 'e2ee' | 'sharedPassphrase'>;\nconst { load, save } = createLocalStorageInterface<TempStorageType>(USER_CHOICES_KEY);\n\n/**\n * Saves user choices to local storage.\n * @alpha\n */\nexport function saveUserChoices(\n  userChoices: LocalUserChoices,\n  /**\n   * Whether to prevent saving user choices to local storage.\n   */\n  preventSave: boolean = false,\n): void {\n  if (preventSave === true) {\n    return;\n  }\n  save(userChoices);\n}\n\n/**\n * Reads the user choices from local storage, or returns the default settings if none are found.\n * @remarks\n * The deprecated parameters `e2ee` and `sharedPassphrase` are not read from local storage\n * and always return the value from the passed `defaults` or internal defaults.\n * @alpha\n */\nexport function loadUserChoices(\n  defaults?: Partial<LocalUserChoices>,\n  /**\n   * Whether to prevent loading from local storage and return default values instead.\n   * @defaultValue false\n   */\n  preventLoad: boolean = false,\n): LocalUserChoices {\n  const fallback: LocalUserChoices = {\n    videoEnabled: defaults?.videoEnabled ?? defaultUserChoices.videoEnabled,\n    audioEnabled: defaults?.audioEnabled ?? defaultUserChoices.audioEnabled,\n    videoDeviceId: defaults?.videoDeviceId ?? defaultUserChoices.videoDeviceId,\n    audioDeviceId: defaults?.audioDeviceId ?? defaultUserChoices.audioDeviceId,\n    username: defaults?.username ?? defaultUserChoices.username,\n  };\n\n  if (preventLoad) {\n    return fallback;\n  } else {\n    const maybeLoadedObject = load();\n    const result = { ...fallback, ...(maybeLoadedObject ?? {}) };\n    return result;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}